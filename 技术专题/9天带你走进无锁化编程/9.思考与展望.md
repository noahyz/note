---
title: 9. 思考与展望
---

## 思考与展望

### 一、无锁队列一定优于有锁队列吗？

不一定，对于 CAS 实现的硬件级的互斥，其单次操作性能比相同条件下的应用层的较为高效，但当多个线程并发时，硬件级的互斥引入的代价与应用层的锁争用同样令人惋惜。因此如果纯粹希望通过使用 CAS 无锁算法及相关数据结构而带来程序性能的大量提升是不可能的，硬件级原子操作使应用层操作变慢，而且无法再度优化。相反通过对有锁多线程程序的良好设计，可以使程序性能没有任何下降，可以实现高度的并发性。

但是我们也要看到应用层无锁的好处，比如不需要程序员再去考虑死锁、优先级反转等棘手的问题，因此在对应用程序不太复杂，而对性能要求稍高时，可以采用有锁多线程。而程序较为复杂，性能要求满足使用的情况下，可以使用应用级无锁算法。

### 二、推荐读物

- 推荐 C++ 实现的无锁线程安全队列项目：https://github.com/cameron314/concurrentqueue

  此项目是比较优秀的多生产者、多消费者的无锁并发队列的工业级别的实现。

- 推荐文章：https://coolshell.cn/articles/8239.html

  陈皓大佬无锁队列的说明与实现

- 推荐文章：https://paul.pub/cpp-memory-model/#id-fence

  对于内存模型讲的特别清楚，本小节关于内存模型的部分大部分参考这篇文章

- 推荐文章：https://en.cppreference.com/w/cpp/atomic/memory_order

  官方对于 memory order 的定义

- 推荐书籍：《C++ 并发编程实战》

  详细说明了 C++ 并发编程中几乎所有技巧

- 推荐文章：https://people.cs.pitt.edu/~xianeizhang/notes/cpp11_mem.html

  C++11 对于内存模型的说明

- 推荐文章：https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.152.5245&rep=rep1&type=pdf

  对于内存屏障的详细说明