---
title: 基础变量的同步需要加锁吗
date: 2023-01-19 11:11:41
tags:
- linux
---

## 基础变量的同步需要加锁吗

我们在加锁时，可能会遇到这种问题，基础变量的同步是否需要加锁？

这个问题我们需要对齐到具体的场景，才能针对具体问题具体化。

### 一、前置条件

在针对此类问题时，我们先明确一下我们要思考那些方向。

- 我们的机器是 64位还是 32位？
- 我们对临界区做的操作是否为原子操作？

因为内存对齐，CPU 的一个读周期或者是一个写周期仅需要一个总线周期，在这个总线周期内就可以处理一个原子操作。一个总线周期结束前 CPU 不会被抢占，就是中断发生也不会导致一个总线周期执行一半时 CPU 被抢占。

比如 `a = 10` 这句代码：

- 在 64 位机器上，假设变量 a 的类型是小于等于 8 字节的。那么 `a=10` 我们就可以认为是原子操作。
- 但是在 32 位机器上，如果变量 a 的类型是 8 字节的。那么 `a=10` 可能就需要 CPU 操作两次，每次操作 4 字节。

我们明白这些之后，再来探讨不同的场景

### 二、对齐场景

我们举例一个场景：64位机器上，有一个 8 字节的全局变量。线程 A 仅对这个全局变量进行读操作；线程 B 仅对这个全局变量进行写操作。那么这两个线程在操作这个全局变量时需要加锁吗？

乍一看，好像不需要加锁。那产生一个问题，那要原子变量 atomic 是用来干嘛的？原因是我们的操作不一定是原子的，比如说线程写操作。`a=10` 和 `a+=10` 这两句代码，区别就很大。`a+=10` 不是原子操作，可以拆分成三条语句：

1. 把 a 读到寄存器中
2. 将寄存器中的值加 10
3. 把寄存器中的值写到 a 中

如果写线程执行的操作不是原子操作，那可能又需要加锁了。

我举一个需要加锁的场景：假设 a 起始为 0，线程 A 的操作为：

```
if (a == 0) {
	b = a + 1;
}
```

那么就有可能出现，刚开始线程 B 执行 `a+=10`，执行了两步之后，线程 A 抢到了 CPU，此时 a 仍然为 0，那么线程 A 读取到 a 为 0 了；然后线程 A 认为 `b=a+1` 的结果应该是 1；但是紧接着线程 B 又抢到了 CPU，执行了第三步，此时 a 为 10 了。然后线程 A 抢到 CPU 执行 `b=a+1` 的结果为 11 了。

这就导致出现了幻读。有点像数据库的隔离级别。这种场景读线程需要使用临界区元素的值，那么就一定需要加锁。

我再举一个不需要加锁的场景：线程 A 获取到 a 的值后，只是做了打印，没有其余操作。那么就不用加锁了，因为线程 A 不管在什么时间，读取到的 a 都是一个完整值。

### 三、小总结

加锁的目的是保护数据的一致性。也就是说，在加锁临界区内，不同线程看到的数据变化是一致的。

如果在不需要保护的情况下，数据本身就可以一致，那也就不用加锁了。