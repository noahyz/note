---
title: 1. 动态链接
---

## 一、为什么需要动态链接

1. 对比静态链接，**对于计算机的内存和磁盘的空间浪费特别严重**。多进程操作系统下，比如每个程序如果都通过静态链接一个 libc.a （至少在 1MB 以上）这样基础的 C 库，那么机器上运行着 100 个这样的程序，就要浪费 100MB 的内存；如果磁盘上有 2000 个这样的程序，就要浪费近 2GB 的磁盘空间。
2. **静态链接对程序的更新、部署和发布也会带来很多麻烦**。比如程序的某一个 lib.o 是第三方厂商提供的，那么如果这个 lib.o 要更新时，整个程序都要重新编译、重新部署、重新发布，工作量极大。

动态链接的思想是**把链接这个过程推迟到了运行时再进行**。有如下好处：

- 解决了共享的目标文件多个副本浪费磁盘和内存空间的问题
- 在内存中共享模块还可以减少物理页面的换入换出，也可以增加 CPU 缓存的命中率，因为不同进程间的数据和指令访问都集中在了同一个共享模块上
- 程序的更新、部署、发布，也只需要更新某一模块即可，当程序再次运行的时候，新版本的目标文件会被自动装载到内存并且链接起来，程序也就完成了升级的目标
- 还可以加强程序的兼容性。一个程序在不同的平台运行时可以动态的链接到由操作系统提供的动态链接库。这些动态链接库相当于在程序和操作系统之间增加一个中间层，从而消除了程序对不同平台之间依赖的差异性。比如：操作系统 A 和 操作系统 B 对于 printf 的实现机制不同，如果是静态链接的程序，那么程序需要分别链接成能够在 A 运行和在 B 运行的两个版本并且分开发布。但是如果是动态链接，只要操作系统 A 和 B 提供一个动态库包含 printf，并且这个 printf 使用相同的接口，那么程序只需要一个版本在两个操作系统上运行。

### 二、装载时重定位

共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。而可执行文件基本可以确定自己在进程虚拟地址空间中的起始位置，因为可执行文件往往是第一个被加载的文件，他可以选择一个固定空闲的地址，比如 linux 下一般是 `0x08040000`。

静态链接又叫做链接时重定位；动态链接被称为装载时重定位。

动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来讲是不同的。当然，动态链接库中的可修改数据部分对于不同的进程来说有多个副本，所以他们可以采用装载时重定位的方法来解决。

Linux 中如果只使用 GCC 中参数 “-shared”，不使用 “-fPIC”，那么输出的共享对象就是使用装载时重定位的方法。

### 三、地址无关代码

使用 GCC 参数 "-fPIC" 可以形成地址无关代码。

装载时重定位，指令部分无法在多个进程之间共享，失去了动态链接节省内存的优势。地址无关代码技术（PIC，Position-independent Code）简单来说，是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

我们把共享对象模块中地址引用按照是否为跨模块分为两类：模块内部引用和模块外部引用；按照不同的引用方式又可以分为：指令引用和数据访问。因此我们就得出了 4 种情况。

- 第一种：模块内部的函数调用、跳转等
- 第二种：模块内部的数据访问，比如模块中定义的全局变量、静态变量
- 第三种：模块外部的函数调用、跳转等
- 第四种：模块外部的数据访问，比如其他模块中定义的全局变量

```c++
static int a;
extern int b;
extern void ext();

void bar() {
		a = 1;  // Type 2
		b = 2;  // Type 4
}
void foo() {
		bar();  // Type 1
		ext();  // Type 3
}
```

#### 1. 模块内部调用或跳转



























