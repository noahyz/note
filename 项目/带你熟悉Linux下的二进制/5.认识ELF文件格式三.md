---
title: 认识 ELF 文件格式（三）
---

## 认识 ELF 文件格式（三）

本篇内容主要分析静态链接、动态链接的概念、原理，以及对应的节，以及这些节的内容。

### 一、链接的由来

比如我们有一个"hello world" 程序，如下：

```c
#include <stdio.h>

int main() {
    printf("hello world\n");
    return 0;
}
```

我们进行编译：`gcc main_03.c -fno-builtin -c -o main_03.o   `  生成 `main_03.o` 这个 ELF 文件。 使用 `-fno-builtin` 是为了禁用内联函数的优化，避免 printf 被优化成 puts。

```
# nm main_03.o
                 U _GLOBAL_OFFSET_TABLE_
0000000000000000 T main
                 U printf
```

然后我们使用 Linux 下的 nm 工具来查看，发现 printf 函数的状态为 U。代表：`"U" The symbol is undefined.` 这个符号没有被定义。

我们知道我们在编译的时候，程序模块 `a.c` 如果要使用其他模块的函数，比如 printf 函数，我们需要知道 printf 函数的地址，但是由于每个模块都是单独编译的，编译器在编译的时候无法得知 printf 函数的地址，因此暂时先将这个 printf 函数搁置。我们刚才看到对于编译成的 `.o` 文件，体现在符号的状态上就是符号未定义。

因此我们知道，我们需要对外部模块的函数、或变量的地址进行修正，肯定不能人工修正，于是就有链接过程。

链接是指在计算机程序的各模块之间传递参数和控制命令，并把它们组成一个可执行的整体的过程。在编写程序的时候，程序员把每个源代码模块独立的进行编译，然后按照需要将它们组装起来，这个组装模块的过程就是链接。这一过程就好像拼图一样，各个模块间依靠符号来通信，定义符号的模块多出一块区域，引用该符号的模块刚好少了那一块区域，两者拼接，完美组合。

### 二、静态链接

现代的链接器一般采用两步链接的方法

- 第一步，空间与地址分配。扫描所有的输入目标文件，并且获得他们的各个段的长度，属性和位置，并且将输入的目标文件中的符号表中所有符号定义和符号引用收集起来，统一放到一个全局符号表。这一步中，链接器将能够获得所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
- 第二步，符号解析与重定位。使用第一步收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等

其中最重要的就是重定位过程了。我们来举一个例子，假设有 a.c 和 b.c 这两个文件

a.c 文件

```
int add(int a, int b) {
    return a + b;
}
```

b.c 文件

```
extern int add(int a, int b);

int main() {
    int a = 10;
    int b = 20;
    add(a, b);
}
```

我们分别编译 a.c 和 b.c。





### 相关节说明

#### 1. .rel.* 和 .rela.* 节

在 ELF 文件中，有一个或多个重定位表的结构专门用于保存与重定位相关的信息。对于可重定位的 ELF 文件来说，他必须包含有重定位表，用来描述如何修改相应段里的内容。对于每个要被重定位的 ELF 段都有一个对应的重定位表，而一个重定位表往往就是 ELF 文件的一个段，所以其实重定位表也被称为重定位段。

比如代码段 `.text` 如果有要被重定位的地方，那么会有一个相对应叫 `.rel.text` 的段保存了代码段的重定位表；如果代码段 `.data` 有被重定位的地方，就会有一个相对应叫 `.rel.data` 的段保存了数据段的重定位表。

我们先来看看名为 `.rela.*` 节，还是只有输出 “hello world” 的二进制程序

```
# readelf --relocs a.out            

Relocation section '.rela.dyn' at offset 0x410 contains 8 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000200db8  000000000008 R_X86_64_RELATIVE                    630
000000200dc0  000000000008 R_X86_64_RELATIVE                    5f0
000000201008  000000000008 R_X86_64_RELATIVE                    201008
000000200fd8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0
000000200fe0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
000000200fe8  000400000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0
000000200ff0  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0
000000200ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0

Relocation section '.rela.plt' at offset 0x4d0 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000200fd0  000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0
```

节的类型为 `SHT_RELA`，意味着他们包含链接器用于执行重定位的信息。实际上，每个 `SHT_RELA` 类型的节都是一个重定位条目，每个条目都详细说明了需要应用重定位的特定地址，以及在该地址插入的特定值。

因为在静态链接过程中，所有在 ELF 文件中的静态重定位都已经被解析，所以这里只显示保留了由动态链接器执行的动态重定位节的信息。

























