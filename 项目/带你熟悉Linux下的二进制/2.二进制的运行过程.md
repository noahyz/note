---
title: 二进制的运行过程
---

## 二进制的运行过程

在上一篇文章中，我们知道了 Linux 下如何生成二进制文件的过程。我们知道首先需要用高级语言写代码，然后预处理器、编译器、汇编器、链接器这些处理完之后，才得到了一个可执行文件。

这个可执行文件运行后，输出 “hello world”。那么这个过程中又发生了什么呢？下面我们一起来学习

### 一、装载可执行文件

当我们运行一个可执行文件时，操作系统会根据可执行文件（ELF 格式）中的 ELF 头信息确定可执行文件的入口点，然后在内存中为该可执行文件分配一块虚拟地址空间，并将可执行文件装载到该空间中。在装载过程中，操作系统会完成一系列的操作，包括对可执行文件中各个段的访问权限和映射关系进行调整，将代码段、数据段和 BSS 段等映射到适当的虚拟地址空间中，等等。

好，如上很快速的叙述完了，现在来细化看看。首先来看进程虚拟地址空间。

**进程虚拟地址空间**

一个程序运行起来之后，我们将其称为进程，进程将会拥有他自己独立的一块虚拟地址空间。这个虚拟地址空间的大小由 CPU 的位数决定，32 位的 CPU 硬件平台决定了虚拟地址空间大小为 0 到 `2^32 -1` ，也就是 4GB 虚拟地址空间大小。而 64 位的硬件平台具有 64 位寻址能力，理论上可以达到 `2^64` 字节。如下是进程虚拟地址空间的划分图。

![](./image/进程虚拟地址空间.png)

在装载的过程中，会把 ELF 文件中的内容，有选择性的填充到进程的内存中，有 覆盖装入、页映射的装载方式。他们所采用的思想都差不多，原则上是利用程序的局部性原理。就是程序用到那个模块，就将那个模块装入内存，如果不用就暂时不装入，存放在磁盘上。

### 二、解析依赖关系

在上一个装载的步骤中，我们二进制本身 ELF 文件进行了装载。但是还没有进行处理动态库。

当可执行文件被装载到内存中后，操作系统会检查可执行文件中的动态链接信息，并在系统的共享库路径中查找所有必要的动态库。如果找到了所需的动态库，则将它们装载到内存中，并解析动态库中的符号表信息。如果某个动态库还依赖于其他动态库，则递归地解析依赖关系，直到所有依赖的动态库都被装载到内存中并解析完毕。

**进程的创建**

我们站在操作系统的角度来看，一个进程的启动会进行如下的步骤：

- 创建一个独立的虚拟地址空间
- 读取可执行文件（ELF 文件）头，并且建立虚拟地址空间与可执行文件的映射关系
- 将 CPU 的指令寄存器设置为可执行文件的入口地址，启动进程的运行。

当我们决定运行二进制文件时，操作系统首先要为运行的程序创建一个进程，其中包括虚拟地址空间。随后，操作系统将“解释器”映射到进程的虚拟内存中。这是一个用户层程序，他知道如何加载二进制文件并执行必要的重定位。在 Linux 操作系统中，解释器通常是一个名为 `/lib64/ld-linux-x86-64.so.2` 的共享库。加载解释器后，内核将控制权转移给他，然后解释器开始他在用户空间的工作。

多说一点，Linux ELF 二进制文件带有一个名为 `.interp` 的特殊的节，该节指定用于加载二进制文件的解释器路径。

```
# readelf -p .interp main

String dump of section '.interp':
  [     0]  /lib64/ld-linux-x86-64.so.2
```

解释器将二进制文件加载到其虚拟地址空间中。然后，解析并找出二进制文件所使用的动态库。解释器将他们映射到虚拟地址空间（使用 mmap 等函数），最后在二进制代码节中执行所有必要的重定位，以填充正确的地址引用动态库。

重定位完成后，解释器将会查找二进制文件的入口点并将控制权转移给入口点，从而开始正常执行二进制文件。

### 三、执行可执行文件

在所有依赖关系解析完毕后，操作系统会将 CPU 的执行流转移到可执行文件的入口点处，并开始执行可执行文件中的代码。可执行文件中的代码会根据需要调用系统函数或共享库函数，并在运行过程中处理输入、输出、异常等事件。在某些情况下，可执行文件可能需要进行内存分配、文件读写、网络通信等操作，这些操作都需要通过系统调用完成。

### 四、小结

在 Linux 上运行一个可执行文件，是一个非常庞大的话题，系统会涉及到多个复杂的步骤。本篇文章只是简单的列举出一些概念指导。为了我们对于 ELF 文件格式的认识铺一个路径。

因此，希望感兴趣的同学自行查阅资源进行深度探索。