---
title: 13.内存
---

我们将物理内存划分成两部分，一部分用来运行内核，一部分用来运行用户进程。因此我们有内核内存池、用户内存池。内存池中管理的是一个个大小为 4K 的内存块，从内存池中获取的内存大小至少为4KB 或者 4KB 的倍数。目前我们将内核内存池和用户内存池的大小设为一致。

我们回顾下分页机制：

- 分页机制下程序中的地址都是虚拟地址
- 虚拟地址的范围取决于地址总线的宽度，因此 32 位环境下，虚拟地址空间为 4GB
- 分页机制下，每个任务都有自己的 4GB 虚拟地址空间。不仅用户进程是这样，内核也是
- 程序中的地址是由链接器在链接过程中分配的，且分配之后就不会变了。运行时按部就班的送上处理器的 CS 和 EIP 寄存器即可

动态申请的内存：

- 程序在运行过程中，动态申请的内存，一般在堆上或者共享区。操作系统接受申请后，为进程或内核自己在堆中选择一空闲的虚拟地址，并且找空闲的物理地址作为此虚拟地址的映射。之后把这个虚拟地址返回给程序
- 所有任务（包括用户进程和内核）都需要给他们维护一个 4GB 的虚拟地址池
- 内核也需要申请内存，并其他绝对有能力不通过内存管理系统申请内存，可以直接使用物理内存。但是这种显的不那么和谐，我们让内核也通过内存管理系统申请内存。因此，内核会从自己的虚拟地址池中分配虚拟地址，再从内核物理内存池（内核专用）中分配物理内存，然后在内核自己的页表将这两种地址建立好映射关系。
- 对于用户进程来说，他向内存管理系统，即操作系统申请内存时，操作系统先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池（所有用户进程共享）中分配空闲的物理内存，然后在该用户进程自己的页表中将这两种地址建立好映射关系。

#### 一、实现过程

我们的 PCB 占用 1 页内存，即 PCB 占用 4KB 大小的内存空间，PCB 所占有的内存必须是自然页，自然页的起始地址必须是 `0xXXXXX000` ，终止地址必须是 `0xXXXXXfff`。也就是不能跨页占用。PCB 必须是完整的、单独的占用一个物理页框。并且任何进程都包含一个 PCB 结构。

PCB 的地址是 `0xXXXXX000`，PCB 的结构是，最低处（从 `0xXXXXX000`开始）以上存储的是进程或者线程的信息，这包括 pid、进程状态等。PCB 的最高处（`0xXXXXXfff`）以下用于进程或线程在 0 特权级下所使用的栈。

因为压栈操作的原理是栈指针 esp 先自减，然后再往自减后的地址处存储数据。因此，任何进程或线程初始的栈顶便是此页框的最顶端+1，即下一个页框的起始处，也就是 `0xXXXXXfff+1`







