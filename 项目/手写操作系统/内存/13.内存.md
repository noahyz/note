---
title: 13.内存
---

我们将物理内存划分成两部分，一部分用来运行内核，一部分用来运行用户进程。因此我们有内核内存池、用户内存池。内存池中管理的是一个个大小为 4K 的内存块，从内存池中获取的内存大小至少为4KB 或者 4KB 的倍数。目前我们将内核内存池和用户内存池的大小设为一致。

我们回顾下分页机制：

- 分页机制下程序中的地址都是虚拟地址
- 虚拟地址的范围取决于地址总线的宽度，因此 32 位环境下，虚拟地址空间为 4GB
- 分页机制下，每个任务都有自己的 4GB 虚拟地址空间。不仅用户进程是这样，内核也是
- 程序中的地址是由链接器在链接过程中分配的，且分配之后就不会变了。运行时按部就班的送上处理器的 CS 和 EIP 寄存器即可

动态申请的内存：

- 程序在运行过程中，动态申请的内存，一般在堆上或者共享区。操作系统接受申请后，为进程或内核自己在堆中选择一空闲的虚拟地址，并且找空闲的物理地址作为此虚拟地址的映射。之后把这个虚拟地址返回给程序
- 所有任务（包括用户进程和内核）都需要给他们维护一个 4GB 的虚拟地址池
- 内核也需要申请内存，并其他绝对有能力不通过内存管理系统申请内存，可以直接使用物理内存。但是这种显的不那么和谐，我们让内核也通过内存管理系统申请内存。因此，内核会从自己的虚拟地址池中分配虚拟地址，再从内核物理内存池（内核专用）中分配物理内存，然后在内核自己的页表将这两种地址建立好映射关系。
- 对于用户进程来说，他向内存管理系统，即操作系统申请内存时，操作系统先从用户进程自己的虚拟地址池中分配空闲虚拟地址，然后再从用户物理内存池（所有用户进程共享）中分配空闲的物理内存，然后在该用户进程自己的页表中将这两种地址建立好映射关系。

#### 一、规划内存池

我们的 PCB 占用 1 页内存，即 PCB 占用 4KB 大小的内存空间，PCB 所占有的内存必须是自然页，自然页的起始地址必须是 `0xXXXXX000` ，终止地址必须是 `0xXXXXXfff`。也就是不能跨页占用。PCB 必须是完整的、单独的占用一个物理页框。并且任何进程都包含一个 PCB 结构。

PCB 的地址是 `0xXXXXX000`，PCB 的结构是，最低处（从 `0xXXXXX000`开始）以上存储的是进程或者线程的信息，这包括 pid、进程状态等。PCB 的最高处（`0xXXXXXfff`）以下用于进程或线程在 0 特权级下所使用的栈。

因为压栈操作的原理是栈指针 esp 先自减，然后再往自减后的地址处存储数据。因此，任何进程或线程初始的栈顶便是此页框的最顶端+1，即下一个页框的起始处，也就是 `0xXXXXXfff+1`

#### 主线程的 PCB

我们内核中有个主线程，就是指正式进入内核时所运行的程序，他调用 init_all 来做各种初始化工作，我们称它为 main 线程，现在来解释下他的 PCB。我们在进入内核之前，通过 `mov esp, 0xc009f000` 将内核所使用的栈指针指向 `0xc009f000`，主线程的 PCB 地址是 `0xc009e000`。

在页表中，我们把低端 1MB 的内存做了对等映射，而 PCB 要占用一个页，所以在低端 1MB 的内存布局中，在 `0x7e00 - 0x9fbff` 这块可用内存空间，我们把 `0x9f000` 作为内核栈顶（`0xc009f000` 对应的物理地址是 `0x9f000`，页表中低端 1M 内存做了对等映射），而不是使用 `0xc009fc00`，因此还浪费了 `0xc00` 字节的空间。

#### 内存位图

现在主线程的 PCB 在 `0xc009e000`，而我们的位图占用 4 页，所以位图地址为 `0xc009a000`。4页位图最大可以管理 512M 的物理内存。

为什么要将位图地址选在低端 1MB 以下呢？内存管理中所使用的数据结构必然也要保存在内存中，即内存管理系统自己也要占用内存。一般的内存管理系统所管理的是哪些空闲的内存，即已经被使用的内存是不在内存池中。已经使用的内存也包括内存管理相关数据结构所占的内存，因此内存位图位于 `0xc009a000`，此地址位于低端 1MB 之内，低端 1MB 之内的内存几乎都被占用了。

#### 内核使用的堆空间

内核也需要动态申请内存，内核使用的堆的起始虚拟地址为：`0xc0100000`。其中 `0xc000_0000` 是内核从虚拟地址 3G 起，而 `0x10_0000` 指跨过低端 1MB 内存，使虚拟地址在逻辑上连续。

因为我们的页目录表和页表是定义在 `[0x10_0000, 0x10_1fff]` ，因此将来的内核虚拟地址 `[0xc010_0000, 0xc010_ffff]` 并不映射到这两个物理地址。

#### 获取安装的物理内存总量

我们在 `loader.s` 中通过三种方法将物理内存总量保存在物理地址 `0x920` 位置处，现在取到他。

#### 页表占用内存

页目录表为 1 页大小，第 0 和第 768 个页目录项指向同一个页表，`[769, 1022]` 个页目录项指向 254 个页表，1023 个页目录项指向页目录表自身。因此页目录表+页表占用的总大小等于 `256*PAGE_SIZE`。

### 二、内存管理系统第一步，分配页内存

我们目前申请内存是按照页为单位申请的，申请的过程，先在位图中寻找 N 个位，这 N 个位对应 N 个页。然后找到之后，将位图的那些位置 1。然后获取到起始页的地址即可。





### 三、内存池的实现

arena 是提供内存分配的数据结构，分为两部分

- 一部分是元信息，用来描述自己内存池中空闲内存块数量，这其中包括内存块描述符指针，通过他可以间接得到本 arena 所包含内存块的规格大小，此部分占用的空间是固定的，为 12 字节
- 另一部分就是内存池区域，里面有数个内存块。

我们的实现中，针对小内存块的 arena 占用一页内存，除了元信息外剩下的内存被平均分成多个小内存块。那么这种 arena 需要存在多个。因此同一类的内存块可以由多个 arena 提供，为了跟踪每个 arena 中的空闲内存块。分别为每一种规格的内存块建立一个内存块描述符，取名：mem_block_desc，记录两个信息，一是内存快的规格大小，二是所有同类 arena 中的空闲内存块链表。

如果申请的内存大于 1024 字节，我们会直接创建一个 arena，并将整块大内存分配出去，此类 arena 没有对应的内存块描述符，元信息中的内存块描述符指针为空。

为什么选择 1024 字节作为划分呢？一页内存 4KB，内存块是平均划分的，所以最大的内存块肯定要小于 2KB，而我们是以 2 为底的指数级划分内存块，因此最大的内存块是 1024 字节。也就是说对内存块规格为 1024 字节的 arena 来说，他只有 3 个内存块，剩余的部分浪费了。

我们的内存块规格包括：16、32、64、128、256、512、1024 字节，总共 7 种规格。

#### 1. 内存申请的实现

我们







































