---
title: 概念
---

1. **什么是任务调度器？**

任务调度器就是操作系统中用于把任务轮流调度上处理器运行的一个软件模块，他是操作系统的一部分。调度器在内核中维护一个任务表（也称为进程表、线程表或调度表），然后按照一定的算法，从任务表中选择一个任务，然后把该任务放到处理器上执行，当任务运行的时间片到期后，再从任务表中找另外一个任务放到处理器上执行。

2. **任务调度器的重难点？**

在多任务系统中，任务切换是软件完成的，切换工作本身要消耗 CPU，导致所有任务的总共执行时间反而更长了。

3. **执行流是什么？**

执行流是独立的，他的独立性体现在每个执行流都有自己的栈、一套自己的寄存器映像和内存资源，这是 Intel 处理器在硬件上规定的，其实这正是执行流的上下文环境。

任何代码块，无论大小都可以独立称为执行流，只要在他运行的时候，我们提起准备好他所依赖的上下文环境即可。

4. **程序、进程、线程**

程序是静态的、存储在文件系统上、尚未运行的指令代码，他是世纪运行时程序的映像

进程是指正在运行的程序，即运行中的程序，程序必须在获取运行所需要的各类资源后才能成为进程，资源包括进程所使用的栈，使用的寄存器等

对于处理器来说，进程是一种执行流集合，集合中至少包含一条执行流，执行流之间是互相独立的，但他们共享进程的所有资源，他们是处理器的执行单位，或者称为调度单位，他们就是线程

按照进程中线程数量划分，进程分为单线程进程和多线程进程两种

进程拥有整个地址空间，其中包括各种资源，而进程中的所有线程共享同一个地址空间。各个进程都拥有自己的虚拟地址空间，正常情况下他们彼此无法访问道对方的内部，因为进程之间的安全性是有操作系统的分页机制来保证的。

5. **线程提速的原理**

原理之一就是实现多个执行流的伪并行。进程采用多个执行流和其他进程抢处理器资源，这样就节省了单个进程的总执行时间。

原理之二是避免了阻塞整个进程，比如当进程因等待用户输入而暂时无法继续运行时，此时操作系统会把整个进程挂起。但如果有多个线程，便可需要挂起一个线程即可，其他线程依然可以上处理器运行。

6. **进程的身份证 --- PCB**

操作系统为每个进程提供了一个 PCB（Process Control Block），即程序控制块。用它来记录与此进程相关的信息，包括：寄存器映像、栈、栈指针、pid、进程状态、优先级、时间片、页表、打开的文件描述符、父进程的 pid 等

- 寄存器映像，用于保存进程的“现场”。一般位于 PCB 的顶端。当进程被换下 CPU 后，当前进程所使用的这一套资源（寄存器内容）应该存在寄存器映像中。任务在此在系统中运行时，会恢复这些寄存器资源
- 进程状态，指明了进程被换下的原因，以及下次调度器是否能把他换上处理器运行
- 时间片，告知了进程应该运行多久，当时间片的值为 0 时，表示该进程此次的运行时间到期了
- 页表，代表进程的地址空间
- 栈，此栈是进程所使用的 0 特权级下内核栈，并不是 3 特权级下的用户栈

#### ABI 规则

ABI：Application Binary Interface，即应用程序二进制接口，ABI 规定的是更加底层的一套规则，属于编译方面的约定。比如参数如何传递，返回值如何存储，系统调用的实现方式，目标文件格式和数据类型等。C 编译器就是按照这套 ABI 规则来编译 C 程序的，倘若我们全是用 C 语言来写程序，那就不用考虑 ABI 规则，这些是编译器考虑的事。C 语言和汇编语言是用不同的编译器来编译的，C 语言代码要先被编译成汇编代码，此汇编代码便是按照 ABI 规则生成的。因此如果要手动写汇编函数，并且此函数要供 C 语言调用的话，必须按照 ABI 规则去写汇编才行

我们的切换线程上 CPU 的函数 switch_to 就是使用的汇编语言，因此我们需要在汇编代码中保存这 5 个寄存器(ebp、ebx、edi、esi、esp)。保存的位置就是在线程栈中

位于 Intel 386 硬件体系上的所有寄存器都具有全局性，因此在函数调用时，这些寄存器对主调函数和被调函数都可见。这 5 个寄存器 ebp、ebx、edi、esi 和 esp 归主调函数所用，其余的寄存器归被调函数所用。也就是说，不管被调函数中是否使用了这 5 个寄存器，在被调函数执行完后，这 5 个寄存器的值不该被改变。因此被调函数必须为主调函数保护好这 5 个寄存器的值，在被调函数运行完之后，这 5 个寄存器的值必须和运行前一样。它必须在自己的栈中存储这些寄存器的值。中 esp 会由调用约定(cdecl、fastcall)来保证，这里不用保护 esp
7. **实现线程的两种方式 --- 内核或用户进程**

线程的实现：

-  由操作系统原生支持，用户进程通过系统调用使用线程。线程在 0 特权级的内核空间中实现（并不是线程所运行的代码也必须是 0 特权级的内核级代码，也可以是 3 特权级的用户级代码）
- 进程自己实现线程，线程在 3 特权级的用户空间实现。通常情况下，标准库提供了用户级线程库，我们直接调用即可

线程仅仅是个执行流，在用户空间，还是在内核空间实现它，最大的区别就是线程表在哪里，由谁来调度它上处理器。

- 如果线程在用户空间中实现，线程表就在用户进程中，用户进程就要专门写个线程用作线程调度器，由他来调度进程内部的其他线程
- 如果线程在内核空间中实现，线程表就在内核中，该线程就会由操作系统的调度器统一调度，无论该线程属于内核，还是用户进程

**在用户空间实现线程？**

- 在用户空间中实现线程的好处就是可移植性强，由于是用户级的实现，所以在不支持线程的操作系统上也可以写出完美支持线程的用户程序
- 在用户空间实现线程，操作系统不会意识到线程的存在，因为操作系统调度器只会以整个进程的方式调度，将处理器的使用权交给这个进程，由进程中的调度器自己去协调分配处理器时间。
- 线程调度涉及到调度器以及线程表。因此，进程还要自己在进程内维护线程表
- 这种方式一般由权威机构发布线程库，开发人员使用此库即可。

在用户空间实现线程的优缺点：

- 优点：线程调度算法由用户程序自己实现，可以根据实际情况为某些线程加权调度

- 优点：将线程的寄存器映像装载到 CPU 时，可以在用户空间完成，即不用陷入内核态，这样就免去了进入内核时的入栈和出栈操作

- 缺点：进程中某个线程如果出现了阻塞（通常由于系统调用引起），操作系统不知道进程中存在线程，操作系统会认为他是传统型进程（单线程进程），因此会将整个进程挂起，导致进程中所有线程都无法运行。

- 缺点：在用户空间实现线程，对于操作系统来说，调度器的调度单元是整个进程，并不是进程中的线程，所以时钟中断只能影响进程一级的执行流。

  进程中某个线程在处理器上运行后，只要该线程不主动让出 CPU，此进程中的其他线程都没有机会运行。也就是说，可能会出现单一线程过度使用 CPU，其他线程没有调度的机会。只能凭借线程主动让出 CPU（通过类似 pthread_yield、pthread_exit），给进程中的其他线程。

- 缺点：线程在用户空间实现线程，和在内核空间实现相比，只是在内部调度时少了陷入内核的代价，但由于整个进程占据 CPU 的时间片是有限的，这有限的时间片还要再分给内部的线程，所以每个线程执行的时间片非常短暂，再加上进程内线程调度器维护线程表、运行调度算法的时间片消耗，反而抵消了内部调度带来的提速

在内核空间中实现线程的优缺点：

- 优点：内核提供的线程相当于让进程多占了 CPU 资源。比如进程 A 创建了 3 个线程，那么在系统中就一共有 4 个线程在和其他进程或者线程在竞争 CPU 时间。
- 优点：当进程中某一线程阻塞后，操作系统只会阻塞这个线程，而这个进程中的其他线程不受影响。就有相当于提速了
- 缺点：用户进程需要通过系统调用陷入内核，这里会增加一些现场保护的栈操作，这还是会消耗一些处理器时间。但和上面两个提速相比，这点消耗可以接受。

Linux 操作系统，在用户空间实现了线程库（POSIX 标准），但 Linux 通常会使用混合模型，将用户空间线程映射到内核空间线程。这种模型称为 `Many-to-One` 模型，其中多个用户空间线程映射到一个内核空间线程。这样可以兼顾用户空间线程的快速切换和内核空间线程的并发执行优势。

我们的系统采用在内核空间中实现线程。