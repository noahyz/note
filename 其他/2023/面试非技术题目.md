### 1. 自我介绍

面试官您好，我是张意。目前在百度的智能驾驶技术部门做后台开发。工作职责是优化智驾系统的性能，提升智驾系统的稳定性，并且为系统做一些性能分析工具，辅助排查性能问题。我熟悉的语言包括 C/C++，汇编、Go 语言。

我这边的工作经历是，我为我们的智驾系统，建设了一整套监控体系。同时，我还会分析一些系统稳定性问题，比如内存暴增、内存越界等等，我对 ptmalloc、jemalloc、tcmalloc 的底层实现是比较熟悉的，曾经解决了我们项目中使用 ptmalloc 的姿势不对，导致 ptmalloc 本身驻留很多内存，引起智驾系统内存暴增问题。对于内存越界问题，我优化过 ASAN 的源码实现，使其仅在一定内存大小的范围内做检测，其余范围不做检测，这样大大降低了性能损耗，在我们的测试中，几乎没有性能损耗，也能检测到内存越界问题。

同时，我熟悉 Linux 下 ELF 文件的格式，对静态链接、动态链接的原理、以及对可执行文件的装载有深入理解。对 Hook 技术有一定研究，我实现了基于 GOT/PLT 的 Hook 库，可以方便的 Hook C 库函数以达到业务目的，曾经使用此库完成了 hook 文件 IO 的相关函数（包括open、close、read、write），完成了磁盘文件 IO 读写量的监控，以及检测文件描述符泄漏、异常关闭等场景。

同时，我有操作系统是非常感兴趣的，我使用 C 语言和汇编语言实现了一个 32 位的操作系统

- 对于机器上电启动、Boot-Loader 引导程序、CPU的实模式到保护模式的跳转、以及中断有非常深入的理解。
- 基于二级页表，实现了内核层面的的内存分页机制，完成虚拟内存与物理内存之间的映射。
- 同时实现了内核级线程、用户级进程，和一个简单的用户级协程
- 参考 linux 下的 ext2 文件系统，实现了完整的文件系统，支持文件、目录的所有操作
- 实现了 fork 系统调用，完成了 shell 界面，目前支持常见的系统操作命令，可以完成简单的系统交互

同时，对一些中间件，比如 redis、mysql 比较熟悉。以上就是我的自我介绍。

### 2. 离职原因（为什么换工作）

- 我还是想做互联网方向的工作，智能驾驶这里完全与大数据脱钩了。
- 总结来说，就是挑战不足，没有压力。我喜欢富有挑战性的工作，我感觉工作、生活、人生都应该精彩一点，做一些有挑战性的、有意义的事情。我这个年纪，目前不太喜欢稳稳当当的生活、工作。
- 而且我目前单身，我想把更多的时间拿出做一些有难度、有深度的事情。

```
33*16 = 52.8
52.8 * 1.3 = 68.64
33 * 1.3 = 42.9
薪资结构，房补、餐补、交通。股票，年终奖几个月
职级
```

### 3. 有什么想问的

- 我们团队做的事情的重点和难点分别是什么？

### 4. 工作内容 - 建设监控体系

-  首先是数据采集。
  - 对于操作系统已经提供的数据，我们通过 proc 文件获取，或者使用 netlink 方式获取。比如：线程的CPU、线程的 IO读写量 
  - 对于操作系统不直接提供的监控数据，我们通过 hook 技术，比如线程的内存使用情况，比如磁盘文件的 IO 读写量。比如对于网络流量的监控，我们截获网卡接收或者发出的报文，然后解析报文，得到每条连接的网络流量。
  - 对于业务的监控数据，我们会提供一些 SDK，保证业务的监控数据可以在单个进程内由数据采集服务线程获取到。
- 数据采集服务线程 将获取到的数据通过共享内存 / 网络通信 的方式，给到 agent。
- agent 将这些数据进行处理、组装，然后重要的是压缩。采用以 proto 的方式组织数据内容，然后以二进制的方式压缩。之后存储到磁盘上。
- 为什么存储到磁盘上，因为车端极有可能没有网络（车库），或者网络不好。通过网络传输极有可能丢失，或者性能不佳
- 最后会将数据通过磁盘的方式，或者在网路良好的情况下。将数据上传到百度云的对象存储。
- 后端的解析服务，则负责读取对象存储中的数据，解析，调整格式，写入 ES 中。前端接口通过查询 ES 并展示数据内容
- 由于数据量比较小。一辆车一天24小时，产生 100M 的数据（1秒 1K），每天有 300 辆测试车在全国各地跑，会产生 30G 的数据。一个系统的设计和紧密结合当前的业务场景，所以后端数据的存储、查询没有设计的很复杂。
- 而把重点放在了如何全量、高效的获取系统层面的监控数据上。我们用到了 hook 技术、netlink 技术、优化了一些中间件（jemalloc）等等。

### 5. ASAN 的优化

在 C/C++ 中，内存越界问题特别难排查，比如，线程 A 在写内存时，写越界了，操作了线程 B 的内存，线程 B 可能过了很久才去访问这块被写坏的内存，然后引起了问题，我们几乎无法从 core 文件中得到有用的信息。

ASAN 是业界所有的内存检测工具中性能最好的。与之对比的 valgrind、gperftools 会严重拖慢程序运行。

先来介绍一下 ASAN。介绍一下 ASAN 的原理。。。

我们的智能驾驶系统运行的环境，也就是实车的 arm 板子，只有 2核2g。 ASAN 工具也没法在实车上有效的运行。因此我们对其进行优化。

ASAN 是集成在 gcc、llvm 中的，由于我们使用的是 gcc 编译器，因此我优化了 gcc 源码中 ASAN 的运行时库实现。也就是优化了 ASAN 库中关于 malloc、free 的实现。

我们发现，发生内存越界时，我们可以通过被踩内存的代码位置，大概分析到附近内存块的大小范围。我们只需要去检测这个内存大小的范围即可。于是我们优化 ASAN 的实现，使其只检测此范围。其他范围使用 ptmalloc 即可。也就是说，在申请内存时，申请的内存块大小在这个范围内，就使用 ASAN 来申请内存；否则就使用 ptmalloc 申请内存。那么这时，就需要考虑释放内存块时，如何判断此内存块是由 ASAN 申请的还是 ptmalloc 申请的？

我们通过研读其源码，发现 ASAN 和 ptmalloc 申请内存块时，一般会多申请 16 字节，放在内存块的头部，并且这个报头会按照一定的方式去组织，我们正是通过 ASAN 和 ptmalloc 报头的组织方式不同来进行判断，此内存块是由 ASAN 申请的还是由 ptmalloc 申请的。从而进行正确的 free 操作。

通过这样的优化原理，我们能够在几乎没有资源损耗的情况下，完成对于内存越界问题的检测。



























