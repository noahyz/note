
### 动态规划
dynamic programming

动态规划和递归或者分治 没有根本上的区别（关键看有无最优的子结构）
共性：找到重复子问题
差异性：最优子结构、中途可以淘汰次优解

1. 斐波那契数列 （一维数组）
2. 路径计数 （二维数组）

状态转移方程（DP方程）
opt[i, j] = opt[i+1, j] + opt[i, j+1]

完整逻辑：
if a[i, j] = '空地':
    opt[i, j] = opt[i+1, j] + opt[i, j+1]
else:
    opt[i, j] = 0

### 动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
2. 存储中间状态：opt[i]
3. 递推公式（美其名曰：状态转移方程或者DP方程）
   Fib：opt[i] = opt[n-1] + opt[n-2]
   二维路径：opt[i, j] = opt[i+1][j] + opt[i][j+1] （且判断 a[i][j] 是否空地）


问题：最长公共子序列
思路：
1. 因为需要求最长子序列，因此我们可以从最后一个字符看起，然后依次向前找
2. 转换为子问题，当找到最后一个相同的字符时，即转换为需要求此字符前面两个字符串的最长公共子序列
3. 经验，转换为二维数组，行和列分别为两个字符串。定义 dp 二维数组时可以为字符串长度+1 
如：字符串 abcde 、ace
|   | a | b | c | d | e |
| a | 1 | 1 | 1 | 1 | 1 |
| c | 1 | 1 | 2 | 2 | 2 |
| e | 1 | 1 | 2 | 2 | 3 |
得出结论：
if S1[n-1] != S2[m-1] : LCS[s1, s2] = Max(LCS[s1-1, s2], LCS[s1, s2-1])
if S1[n-1] == S2[m-1] : LCS[s1, s2] = LCS[s1-1, s2-1] + 1

小结：
1. 打破自己的思维惯性，形成机器思维
2. 理解复杂逻辑的关键
3. 也是职业进阶的要点要领


实战题目：
爬楼梯
1. 可以爬1，2，3级台阶: F(n) = F(n-1)+F(n-2)+F(n-3)
2. 相邻两步的步伐不能相同。