---
title: undefined
date: 2023-01-19 11:11:41
tags:
- linux
---

### 一、相交链表

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

两个链表在节点 c1 开始相交：如下：

```
A1 -> A2 -> C1 -> C2 -> C3
B1 -> B2 -> C1 -> C2 -> C3
```

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        
    }
}
```

### 二、反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。比如：

```
原始链表： 1 -> 2 -> 3 -> 4 -> 5 
反转后链表: 5 -> 4 -> 3 -> 2 -> 1
```

代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {

    }
}
```

### 三、合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 比如：

```
原始链表one： 1 -> 2 -> 4
原始链表two： 1 -> 3 -> 4
合并后链表：  1 -> 1 -> 2 -> 3 -> 4 -> 4
```

代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

    }
}
```



