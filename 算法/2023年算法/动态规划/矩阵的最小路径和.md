---
title: 矩阵的最小路径和
---

## 矩阵的最小路径和

### 一、题目

给定一个包含非负整数的 m x n 网格 grid，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

leetcode：https://leetcode.cn/problems/minimum-path-sum/

类似题目，不同路径：https://leetcode.cn/problems/unique-paths/

### 二、思路

典型的动态规划类题目，最终要走到右下角，这个矩阵长为 m，宽为 n。右下角为 [m-1, n-1] 位置，每一次只能走一步，那就要不是 [m-2, n-1] 走过来的，要不就是 [m-1, n-2] 走过来的，所以 [m-1, n-1] 的值应该为 `std::min(arr[m-2, n-1], arr[m-1, n-2]) + 1`。因此我们每一步需要选择最小的路径来走就好了。

第一行和第一列只能横着走，或者只能竖着走。所以只能填充原始数组即可。所以我们还是申请的是和原二维数组一样大小的数组，并且填充第一行和第一列。其他行和列，每次取最小路径即可。

### 三、code

```c++
class Solution {
public:
    int minPathSum(std::vector<std::vector<int>>& grid) {
        if (grid.empty()) {
            return 0;
        }
        int m = grid.size();
        int n = grid[0].size();
        std::vector<std::vector<int>> res(m, std::vector<int>(n, 0));
        res[0][0] = grid[0][0];
        for (size_t i = 1; i < n; ++i) {
            res[0][i] = grid[0][i] + res[0][i-1];
        }
        for (size_t i = 1; i < m; ++i) {
            res[i][0] = grid[i][0] + res[i-1][0];
        }
        for (size_t row = 1; row < m; ++row) {
            for (size_t line = 1; line < n; ++line) {
                res[row][line] = std::min(res[row-1][line], res[row][line-1]) + grid[row][line];
            }
        }
        return res[m-1][n-1];
    }
};
```

时间复杂度：`O(m * n)` ，空间复杂度：`O(m * n)`