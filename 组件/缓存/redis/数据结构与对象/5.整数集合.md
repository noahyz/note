---
title: 整数集合
---

当一个集合只包括整数值元素，并且这个集合的元素数量不多时，redis 会使用整数集合作为集合键的底层实现。

比如：`SADD numbers 1 3 5 7 9`；这个集合键的底层就是整数集合。

## 一、实现

他可以保存类型为 `int16_t、int32_t、int64_t` 的整数值，并且**保证集合中不会出现重复元素，并且有序**

```
typedef struct intset {
		// 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

contents 数组的真正类型取决于 encoding 属性的值：

- 如果 encoding 为 `INTSET_ENC_INT16`，那么 contents 就是一个 `int16_t` 类型的数组。
- 同理 encoding 为 `INSET_ENC_INT32、INSET_ENC_INT64`，那么 contents 就是一个 `int32_t` 和 `int64_t` 类型的数组。
- 假设，保存的是 16 位数字，length 为 5，则 contents 数组的大小为 `sizeof(int16_t)*5 = 80`

### 1. 升级

当将一个新元素添加到整数集合时，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合中。分三步走：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到相应的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变
- 将新元素添加到底层数组中

升级的好处：

- 提升整数集合的灵活性。整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意的将 `16、32、64` 位类型的数据添加到集合中，而不必担心出现类型错误，这种做法比较灵活
- 节约内存。小类型数据使用小类型存储，而不是统一使用 64 位类型存储。

整数集合不支持降级操作，哪怕集合中 64 位的数据都删除了，编码仍然会维持 64 位类型。

