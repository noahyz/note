---
title: 浮点数的误差
---

## 浮点数的误差

如下的一段 java 代码

```
public static void main(String[] args) {
  double dValue = 0.99999999999999998 * 10;
  int value = (int) (dValue);
  System.out.println("before:" + dValue + ", after:" + value);
}
```

这段代码的输出是`before:10.0, after:10`。这说明，即使我们的浮点数是一个接近1的数，乘以10后的结果也可能等于10。这就是浮点数误差导致的问题。

程序输出9 到 10的精确分割点是 0.99999999999999995 （小数点之后的16位数字），math.random 产生的是均匀分布，所以发生概率大概是10^16之1

#### GPT Answer:

这是因为浮点数在计算机中的表示和计算都是有误差的。在你的例子中，0.9999999999999999999999这个数在计算机中无法精确表示，它会被四舍五入到最接近的可表示的浮点数，这个数可能就是1.0。然后1.0乘以10得到10.0，再强制转换为int类型，结果就是10。

这是由于IEEE 754浮点数标准的限制。在这个标准中，一个double类型的数有52位的精度，也就是说，它可以精确表示大约15位的十进制数。而你的数0.9999999999999999999999有超过20位的精度，所以在转换为double类型时就会有舍入误差。

这也是为什么在处理涉及到浮点数的计算时，我们需要特别小心，因为可能会有舍入误差。在你的例子中，如果你需要得到的结果是9而不是10，你可以考虑使用BigDecimal类来进行精确的数值计算。