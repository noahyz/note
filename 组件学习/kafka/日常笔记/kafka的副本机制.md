---
title: undefined
date: 2023-01-19 11:11:41
tags:
- linux
---

副本机制的好处

```
1. 提供数据冗余。即使系统部分组件失效，系统依然能够继续运转，因而增加了整体可用性以及数据持久性
2. 提供高伸缩性。支持横向扩展，能够通过增加机器的方式来提升读性能，进而提高读操作吞吐量
3. 改善数据局部性。允许将数据放入与用户地理位置相近的地方，从而降低系统延时
```

kafka的副本机制

```
目前kafka只 "提供数据冗余" 实现高可用性和高持久性
副本的概念实际上是在分区层级下定义的，每个分区配置有若干个副本

副本本质上就是一个只能追加写消息的提交日志，同一个分区下的所有副本保存有相同的消息序列，这些副本分散保存在不同的Broker上，从而能够对抗部分Broker宕机带来的数据不可用

1. kafka中，副本分为：领导者副本、追随者副本。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本
2. kafka中，追随者副本是不对外提供服务的。追随者副本唯一的任务就是从领导者副本异步拉取消息，并写入自己的提交日志中，从而实现与领导者副本的同步
3. 当领导者副本挂掉后，或者说领导者副本所在的Broker宕机时，kafka依托于Zookeeper提供的监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老Leader副本重启回来后，只能作为追随者副本加入到集群中
```

kafka的这种副本机制的好处

```
1. 方便 Read-your-writes：当使用生产者API向Kafka 成功写入消息后，马上使用消费者API去读取刚才生产的消息。如果允许追随者副本提供服务，就可能导致不能及时拉取到消息
2. 方便实现单调读(Monotonic Reads)：对于一个消费者用户而言，在多次消费消息时，它不会看到某条消息一会儿存在，一会儿不存在。比如，两个追随者副本拉取数据的时机不一致，消费者先读的F1，读到了D1，但是第二次读F2时读不到了。
```

In-sync Replicas（ISR）：ISR副本集合（如何确认追随者副本是和领导者副本同步的？）

```
ISR中的副本都是与Leader同步的副本，相反，不在ISR中的追随者副本就被认为是与Leader不同步的。
ISR中不只是追随者副本集合，必然包括Leader副本。甚至某些情况下，ISR只有Leader这一个副本

Broker端参数：replica.lag.time.max.ms：Follow副本能够落后Leader副本的最长时间间隔(Leader 发现 Follower 超过这个参数所设置的时间没有向他发起fetch复制请求)，默认值为10秒。那么 Leader 考虑将这个 Flower 从 ISR 移除。
如果被踢出ISR集合中的Follower追上了Leader 的进度，那么他是能够重新被加回 ISR 中的，表明：ISR 是一个动态调整的集合，而非静态不变的
```

Unclean领导者选举(Unclean Leader Election)

```
如果ISR集合为空了，即Leader副本也挂掉了，Kafka需要重新选举一个新的Leader，是否要选取非同步追随者副本？
Broker端参数 unclean.leader.election.enable：控制是否允许 Unclean 领导者选举

1. 开启 Unclean 领导者选举可能会造成数据丢失，但分区Leader副本一直存在，不至于停止对外服务，提升了高可用性
2. 禁止 Unclean 领导者选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性
建议：不要开启它，我们有其他方式来提升高可用性，如果为了这点高可用性的改善，牺牲了数据的一致性，那就不值了
```

CAP理论

```
一个分布式系统通常只能同时满足 一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance) 中的两个
kafka赋予使用者选择了 C 和 A 的权利
```

