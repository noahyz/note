kafka支持两种消息引擎模型

```
1. 点对点模型：消息队列模型。系统A发送的消息只能被系统B接收，其他任何系统不能读取A发送的消息
2. 发布/订阅模型：存在多个发布者向相同的主题发送消息，而订阅者也可能存在多个，他们都能接收到相同主题的消息
```

系统A不能直接发送消息给系统B，中间还要隔一个消息引擎，是为了“削峰填谷”

kafka的高可用：

```
服务器端：kafka的服务器端由被称为Broker的服务进程构成，即一个kafka集群由多个Broker组成，Broker负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个Broker进程能够运行在同一台机器上，但更常见的做法是将不同的Broker分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在他上面运行的所有Broker进程都挂掉了，其他机器上的Broker也依然能够对外提供服务。这是kafka提供高可用的手段之一。

另一个高可用手段是备份机制。备份就是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在kafka中被称为副本。副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用。kafka定义了两类副本：领导者副本(Leader-Replice)和追随者副本(Follower-Replica)。前者对外提供服务，指的是与客户端程序进行交互；而后者只是被动的追随领导者副本而已，不能与外界进行交互。
-- 这里追随者副本只是备份数据吗？为什么不读写分离(消息如何保证一致性)？
```

副本的工作机制

```
生产者总是向领导者副本写消息；而消费者总是从领导者副本读消息。至于追随者副本，它只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。
-- 这里的追随者副本只是保存领导者副本生产的消息吗？？？？
```

分区机制

```
kafka中的分区机制指的是将每个主题划分成多个分区，每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区0中，要么在分区1中。kafka的分区编号是从0开始的

每个分区下可以配置若干个副本，其中只能有1个领导者副本和N-1个追随者副本。
生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移(Offset)的数据来表征。分区位移总是从0开始
```

kafka的消息架构总结

```
1. 主题层：每个主题可以配置M个分区，而每个分区又可以配置N个副本
2. 分区层：每个分区的N个副本中只能有一个充当领导者角色，对外提供服务；其他N-1个副本是追随副本，只是提供数据冗余之用
3. 消息层：分区中包含若干条消息，每条消息的位移从0开始，依次递增
4. 客户端程序只能与分区的领导者副本进行交互
```

持久化数据

```
kafka使用消息日志来保存数据，一个日志就是磁盘上一个只能追加写消息的物理文件。比随机I/O操作快 ---- 这里为什么？ --高吞吐量
kafka定期的删除消息以回收磁盘。通过日志段机制。在kafka底层，一个日志又进一步细分成多个日志段，消息被追加到当前最新的日志段中，当写满了一个日志段后，kafka会自动切分出一个新的日志段，并将老的日志段封存起来。kafka在后台还是定时任务定期检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。
```

kafka版本号

```
Binary downloads:
- Scala 2.11 - kafka_2.11-2.2.1.tgz
前面的版本是编译kafka源代码的Scala编译器版本。真正的版本号实际上是2.2.1。即大版本-小版本-修订版本
```

