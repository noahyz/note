## 一、编码

Redis 中五种类型的对象都是由如下结构表示

```c
typedef struct redisObject {
	// 类型
	unsigned type:4;
	// 编码
	unsigned encoding:4;
	// 指向底层实现数据结构的指针
	void *ptr;
	// ...
} robj;
```

对象的编码

| 编码常量                  | 编码所对应的底层数据结构    |
| ------------------------- | --------------------------- |
| REDIS_ENCODING_INT        | Long 类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr 编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串              |
| REDIS_ENCODING_HT         | 字典                        |
| REDIS_ENCODING_LINKEDLIST | 双端链表                    |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                    |
| REDIS_ENCODING_INTSET     | 整数集合                    |
| REDIS_SKIPLIST            | 跳跃表和字典                |

## 二、对象

### 1. 字符串对象

字符串对象的编码可以是 init、raw 或者 embstr

- 如果一个字符串对象保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long），并将字符串对象的编码设置为 int
- 如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于 39 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置 为 raw
- 如果字符串对象保存的字符串值长度小于等于 39 字节，那么字符串对象将使用 embstr 编码的方式来保存
- 可用用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的，先将浮点数转换为字符串再保存

int、embstr 编码的字符串对象在条件满足时，会被转换成 raw 编码的字符串对象。比如：

```shell
127.0.0.1:6379> set number 888
OK
127.0.0.1:6379> object encoding number
"int"
127.0.0.1:6379> append number " nihao"
(integer) 9
127.0.0.1:6379> get number
"888 nihao"
127.0.0.1:6379> object encoding number
"raw"
```

embstr 字符串实际上是只读的，当我们想要修改时，会先将 embstr 转换成 raw，然后在修改

### 2. 列表对象

列表对象的编码可以是 ziplist 或者 linkedlist

- 当列表对象保存的所有字符串元素的长度都小于64字节；且列表对象保存的元素数量小于512个；使用 ziplist 编码
- 否则使用 linkedlist 编码

当使用 ziplist 编码所需的两个条件的任意一个不能被满足时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表中，对象的编码也会从 ziplist 变为 linkedlist

### 3. 哈希对象

哈希对象的编码可以是 ziplist 或者 hashtable

- 当哈希对象保存的所有键值对的键和值的字符串长度都小于64字节，且哈希对象保存的键值对数量小于512个时，使用 ziplist 编码
- 否则使用 hashtable 编码

#### 4. 集合对象

集合对象的编码可以是 intset（整数集合） 或者 hashtable（字典）

- 当集合对象保存的所有元素都是整数值，且元素数量不超过 512 个，使用 intset 编码
- 否则，使用 hashtable 编码

#### 5. 有序集合对象

有序集合的编码可以是 ziplist（压缩列表） 或者 skiplist（zset结构 -- 包含字典和跳跃表）

虽然 zset 结构同时使用了字典和跳跃表，但是两种数据结构都通过指针来共享相同元素的成员和分值，所以不会产生任何重复成员或分值，不会浪费空间

- 当有序集合保存的元素数量小于 128 个，且所有元素成员的长度都小于 64 字节，则使用 ziplist 编码
- 否则使用 skiplist 编码

## 三、底层实现

### 1. 内存回收

采用引用计数技术实现内存回收机制

### 2. 对象共享

如果多个键的对象值都相同，对于相同的对象值，这些键就会同时指向这个对象。节省空间。

举例：Redis 在初始化服务器时，创建一万个字符串对象，这些对象包含了从 0 到 9999 的所有整数值，当服务器需要用到值为 0 到 9999 的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

```
// 查看键 a 所对应的值对象的引用计数
object refcount a
```

### 3. 对象的空转时长

redisObject 结构包含一个属性为 lru ，该属性记录了对象最后一次被命令程序访问的时间。

```
// 查看键 msg 的空转时长
object idletime msg
```

空转时长是通过将当前时间减去键的值对象的 lru 时间计算得出的。当服务器占用的内存过高，需要清理时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。
