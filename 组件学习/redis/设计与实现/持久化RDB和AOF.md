## 一、RDB 持久化

RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件。有 SAVE 和 BGSAVE 命令

- SAVE 命令会阻塞 Redis 服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求
- BGSAVE 命令会派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程继续处理客户端命令
- 当服务器执行 BGSAVE 时，客户端发送的SAVE命令会被服务器拒绝

RDB 文件的载入工作是在服务器启动时自动执行的，且为阻塞的。因为AOF文件的更新频率比RDB文件的更新频率高，所以服务器如果开启了AOF持久化功能，优先使用AOF文件还原数据库状态。只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件还原数据库状态

### 1. 保存条件

服务器“自动间隔性保存”配置，让服务器定时去 BGSAVE。Redis 服务器会默认 100ms 执行一次函数 serverCron ，这个函数其中一项工作就是检查 save 选项设置的保存条件是否满足，如果满足就执行 BGSAVE 命令

```shell
save 900 1  # 服务器在 900 秒之内，对数据库进行了至少1次修改，下同
save 300 100
save 60 10000
```

- dirty 计数器记录距离上一次成功执行 SAVE 命令或者 BGSAVE 命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（增删改）
- lastsave 属性是一个 unix 时间戳，记录了服务器上一次成功执行 SAVE / BGSAVE 命令的时间

### 2. RDB 文件结构

```
| REDIS | db_version | databases | EOF | check_sum |
```

- REDIS 部分是固定的 5 个字节，保存“REDIS”五个字符
- db_version 长度为 4 个字节，是一个字符串表示的整数，比如“0006”
- databases 部分包含着零个或者任意多个数据库，以及各个数据库中的键值对数据
- EOF 常量的长度为 1 个字节，标志着 RDB 文件正文内容的结束
- check_sum 是一个 8 字节长的无符号整数，保存着校验和，这个校验和是程序通过对前四个部分的内容进行计算得出的。在载入RDB文件时，会将载入数据所计算的校验和与 check_sum 所记录的校验和进行对比，判断是否出错或者损坏。

### 3. 分析 RDB 文件

```shell
# -c：以 ASCII 编码的方式打印输入文件
# -x：以十六进制的方式打印输入文件
od -c -x dump.rdb
```

## 二、AOF 持久化

AOF 持久化通过保存 Redis 服务器所执行的命令来记录数据库状态的。此功能的实现可以分为：命令追加、文件写入、文件同步三个步骤

1. 命令追加

    服务器执行完一个写命令之后，会以一定的协议格式将被执行的写命令追加到名为 aof_buf 的 AOF 缓冲区的末尾

2. AOF 文件的写入和同步

    Redis 服务器进程是一个事件循环，服务器每次结束一个事件循环之前，都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓冲区的内容写入和保存到 AOF 文件里面。不同的 appendfsync 值产生不同的持久化行为

    | Appendfsync 选项的值 | flushAppendOnlyFile 函数的行为                               |
    | -------------------- | ------------------------------------------------------------ |
    | always               | 将 aof_buf 缓冲区中所有内容写入并同步到AOF文件               |
    | everysec             | 将 aof_buf 缓冲区中所有内容写入到AOF 文件，如果上次同步AOF文件的时间距离现在超过一秒钟，那么再次对AOF文件进行同步，并且这个同步操作是由一个线程专门负责执行的 |
    | no                   | 将aof_buf 缓冲区中的所有内容写入到AOF文件，但并不对AOF文件进行同步，何时同步由操作系统决定 |

    注意：现在操作系统，当调用 write 函数写数据到文件时，操作系统通常将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正的将缓冲区中数据写入到磁盘。操作系统提供 fsync / fdatasync 两个同步函数。上面的同步即真正的写入磁盘。

AOF 文件的载入与数据还原：AOF 文件包含了重建数据库状态所需的所有写命令，因此只需要读入并重写执行一遍即可。需要创建一个不带网络的伪客户端。

### 1. AOF 重写

命令：BGREWRITEAOF 进行 AOF 后台重写

由于 AOF 文件中内容会越来越多。会出现很多无用的 redis 操作写日志；AOF 重写功能通过读取服务器当前的数据库状态来实现。

AOF 重写实现函数：aof_rewrite 函数的实现：遍历所有数据库的所有键，忽略过期的键，根据键的类型获取到键包含的所有元素，组装写入语句。写入新的 aof 文件。

Redis 将 AOF 重写程序放到子进程执行。这样做达成两个目的，引起了一个影响

- 目的：子进程进行 AOF 重写期间，服务器进程可以继续处理客户端命令请求
- 目的：子进程带有服务器进程的数据副本，使用子进程，可以避免使用锁的情况下，保证数据的安全性

- 影响：子进程在进行 AOF 重写期间，主服务器进程还需要继续处理客户端写命令请求，导致当前服务器的数据库状态和AOF文件所保存的数据库状态不一致

解决：Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，他会同时将这个写命令发送给 AOF 缓冲区和AOF 重写缓冲区。

当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程收到信号后，调用一个信号处理函数，执行如下操作：

- 将 AOF 重写缓冲区中的所有内容写入新的 AOF 文件中，这时新 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致
- 对新的AOF 文件进行改名，原子的覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换

在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，这将 AOF 重写对服务器性能造成的影响降到了最低。