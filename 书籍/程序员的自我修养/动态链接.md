---
title: undefined
date: 2023-01-19 11:11:41
tags:
- linux
---

## 动态链接

### 一、为什么需要动态链接

静态链接有缺陷

- 内存占用大。如果是静态库，每个运行的程序都需要使用公共的静态库（例如 glibc.a），那么如果一个静态库 1MB，100 个进程就需要浪费 100MB 的内存
- 磁盘占用大，如果是静态库，每个二进制都包含了公共的静态库（例如 glibc.a），那么如果一个静态库 1MB，系统上 1000 个二进制，就占用 1GB 的磁盘空间
- 如果使用静态库，程序的开发、更新、部署、发布都比较困难。一个模块的改动需要整个二进制重新编译。

### 二、动态链接概念

- 仅仅 `-shared`：装载时重定位。代码不是地址无关的，无法被多个进程共享；无法节省内存。实现需要修改指令（代码段内容）
- `-fPIC`：地址无关代码，指令部分保持不变，数据部分在每个进程中拥有一个副本。
  - 注意：由于地址无关代码都是和硬件平台相关的，不同的平台有着不同的实现，“-fpic” 在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而“-fPIC” 则没有这样的限制。所以请使用 “-fPIC”

#### 1. 代码段地址无关性，共享对象模型中的地址引用可以划分成四类：

##### <1>. 模块内部的函数调用、跳转等

可以是相对地址调用，或者是基于寄存器的相对调用，这种指令是不需要重定位的。

存在全局符号介入问题。也就是一个二进制依赖的两个 so 库中有相同的符号，linux 下的动态链接器是这样处理的：当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。

##### <2>. 模块内部的数据访问，比如模块中定义的全局变量、静态变量

ELF 文件的数据段和代码段，也就是指令与数据的相对位置是固定的。那么只需要当前指令加上固定的偏移就可以访问模块的内部数据。

对于模块中的全局变量需要注意，编译器在编译的时候无法根据上下文判断这个全局变量是定义在同一个模块的其他目标文件还是定义在另外一个共享对象之中，也就是说无法判断是否跨模块间的调用。

由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来，因此链接器会在可执行文件的 ".bss" 段创建全局变量的副本。因此出现同一个变量出现在多个位置，ELF 会让所有使用这个变量的指令都指向位于可执行文件中的那个副本。

ELF 共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其他模块的全局变量。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把 GOT 中的相应地址指向该副本。如果这个全局变量在共享模块中被初始化，那链接器还需要将其值复制过来。

##### <3>. 模块外部的函数调用、跳转等

和模块外部的数据访问方式类似。GOT 中保存函数地址。当模块要调用目标函数时，可以通过 GOT 中的项进行间接跳转。

动态链接慢是因为：(1). 动态链接对于全局和静态的数据访问、模块间的调用要进行复杂的 GOT 定位，然后间接寻址、跳转。(2). 动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作。

ELF 的优化，不用一开始就链接共享库的所有函数，采用一种叫做延迟绑定的做法，当函数第一次被用到时才进行绑定（符号查找、重定位等）。增加 PLT（Procedure Linkage Table）表作为中介。每个外部函数在 PLT 中都有一个相应的项。

```
bar@plt
jmp *(bar@GOT)
push n
push moduleID
jump _dl_runtime_resolve
```

bar@GOT 表示 GOT 中保存 bar() 这个函数相应的项。为了实现延迟绑定，链接器将 "push n" 填入到 bar@GOT 中，然后根据重定位表完成符号解析和重定位，之后将 bar() 的真正地址填入到 bar@GOT 中。而这个过程只会在符号未被解析时执行一次。

##### <4>. 模块外部的数据访问，比如其他模块中定义的全局变量

因为模块间的数据访问目标地址要等到装载时才决定。而我们要做到代码地址无关，基本的思想就是把跟地址有关的部分放到数据段。ELF 的做法是在数据段里面建立一个指向这些变量的指针数组，也被称为全局偏移表（Global Offset Table，GOT）。GOT 是指向这些变量的指针数组。模块在编译的时候可以确定 GOT 相对于当前指令的偏移，然后再根据变量地址在 GOT 中的偏移就可以得到变量的地址。

#### 2. 数据段地址无关性

```
static int a;
static int* p = &a;
```

指针 p 的地址就是一个绝对地址，指向变量 a，而变量 a 的地址会随着共享对象的装载地址改变而改变。

- 数据段对于每个进程来说，都是独立的，因此装载时重定位即可解决数据段中绝对地址引用问题
- 对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。

#### 3. 动态链接相关结构

- 段 ".interp"：保存的是动态链接器的路径
- 段 ".dynamic"：保存了动态链接器所需要的基本信息，比如依赖于那些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等
- 动态符号表 ".dynsym"：只保存了与动态链接相关的符号。很多时候动态链接的模块同时拥有 ".dynsym" 和 ".symtab" 两个表，".symtab" 中往往保存了所有符号，包括 ".dynsym" 中的符号
- 动态链接重定位表，".rel.dyn" 是对数据引用的修正，他所修正的位置位于 ".got" 以及数据段；而 ".rel.plt" 是对函数引用的修正，他所修正的位置位于 ".got.plt"

### 三、动态链接的实现

动态链接器本身的重定位工作：

- 动态链接器本身不可以依赖其他任何共享对象，可以人为控制
- 动态链接器所需要的全局和静态变量的重定位工作由他本身完成。这部分代码被称为自举。不能使用全局变量和静态变量，也不允许使用函数。

动态链接器完成自举之后，将可执行文件和链接器本身的符号表都合并到一个符号表中，也就是全局符号表。全局符号表包含进程中所有的动态链接所需要的符号。

- 对于符号的优先级。当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略。
- 这里注意，多个共享库的全局符号可能会导致程序存在非期望的逻辑。如果不是一个导出符号，最好加上 static 修饰。

重定位完成之后，如果某个共享对象有 ".init" 段，那么动态链接器会执行 ".init" 段中的代码，用以实现共享对象特有的初始化过程，比如常见的 c++的全局/静态对象的构造就需要通过 ".init" 段来初始化。进程退出时，也会执行 ".finit" 段中的代码，用来实现类似 c++ 全局对象析构之类的操作

链接器的工作至此完成，将进程的控制权转交给程序的入口并且开始执行。

链接器不仅是一个 so 库，同时也是可执行的。动态链接器本身是静态链接的，并且也是 PIC 的。

### 四、显示运行时链接

dlopen、dlsym、dlerror、dlclose 四个函数可以帮助我们显示使用动态库。

dlopen 中：

- RTLD_LAZY 表示延迟绑定
- RTLD_NOW 表示当模块被加载时即完成所有函数的绑定工作，如果有未定义的符号引用的绑定没法完成
- RTLD_GLOBAL：可以和上面两个一起使用（或的关系）。表示被加载的模块的全局符号合并到进程的全局符号表中，使得以后加载的模块可以使用这些符号。

dlopen 加载模块时也会执行 ".init" 段的代码，dlclose 释放模块时也会执行 ".finit" 段的代码。













