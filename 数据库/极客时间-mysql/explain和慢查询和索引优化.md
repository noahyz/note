## 一、explain 的使用

Explain 可以获取 MySQL 中 SQL 语句的执行计划，比如语句是否使用了关联查询、是否使用了索引、扫描行数等。可以帮我们选择更好地索引和写出更优的 SQL。使用方法：在 SQL 语句前面加上 explain 运行就可以了。 

```
mysql> explain select * from user where name = '6';
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | user  | NULL       | ref  | name_index    | name_index | 363     | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
```

| 列名          | 描述                                                     |
| ------------- | -------------------------------------------------------- |
| id            | 在一个大的SQL语句中每个 select 关键字都对应一个唯一的 id |
| select_type   | SQL语句类型                                              |
| table         | 表名                                                     |
| partitions    | 匹配的分区信息                                           |
| type          | 针对单表的访问方法                                       |
| possible_keys | 可能使用到的索引                                         |
| key           | 实际上使用的索引                                         |
| key_len       | 实际使用的索引长度                                       |
| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| rows          | 预估需要读取的记录数                                     |
| filtered      | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| Extra         | 一些额外的信息                                           |

##### 1. select_type 列一部分解释

| select_type 的值 | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| SIMPLE           | 简单查询（不使用关联查询或子查询）                           |
| PRIMARY          | 如果包含关联查询或者子查询，则最外层的查询部分标记为 primary |
| UNION            | 联合查询中第二个及后面的内容                                 |

##### 2. type 列

| type 的值       | 解释                                                         |
| --------------- | ------------------------------------------------------------ |
| system          | 查询对象列只有一行数据，且只能用于 MyISAM 和 Memory 引擎的表，这是最好的情况 |
| const           | 基于主键或唯一索引查询，最多返回一条结果                     |
| eq_ref          | 表连接时基于主键或非 NULL 的唯一索引完成扫描                 |
| ref             | 基于普通索引的等值查询，或者表间等值连接                     |
| fulltext        | 全文索引                                                     |
| ref_or_null     | 表连接类型是 ref，但进行扫描的索引列中可能包含 NULL 值       |
| index_merge     | 利用多个索引                                                 |
| unique_subquery | 子查询中使用唯一索引                                         |
| index_subquery  | 子查询中使用普通索引                                         |
| range           | 利用索引进行范围查询                                         |
| index           | 全索引扫描                                                   |

##### 3. extra 列解释

| Extra 常见的值                          | 解释                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| Using index                             | 使用覆盖索引                                                 |
| Using index condition                   | 先条件过滤索引，在查数据                                     |
| Using where                             | 使用 where 语句来处理结果                                    |
| Using temporary                         | 需要创建一个临时表来存储结构，通过发生对没有索引的列进行 Group By 时 |
| Impossible where                        | 对 where 子句判断的结果总是 false 而不能选择任何数据         |
| Using join buffer ( Block Nested Loop ) | 关联查询中，被驱动表的关联字段没有索引                       |
| Select tables optimized away            | 使用某些聚合函数（比如 max、min）来访问存在索引的某个字段    |

## 二、慢查询

##### 1. 使用 show processlist 定位，查询正在执行的慢查询

可以显示哪些线程正在运行，如果有 process 权限，则可以看到所有线程；否则，只能看到当前会话的线程。

注：`show full processlist ` 可以看到语句的全部内容，否则只能显示每个语句的前 100 个字符

##### 2. 根据慢查询日志定位

MySQL 的慢查询日志记录的内容是：在 MySQL 中响应时间超过参数 long_query_time（单位秒，默认值为10）设置的值，并且扫描记录数不小于 min_examined_row_limit（默认值 0）的语句

MySQL  慢查询的相关参数解释：

- slow_query_log：是否开启慢查询日志，1 表示开启，0 表示关闭。默认是 FALSE 
- slow_query_log_file：5.6 以上版本，MySQL 数据库慢查询日志存储路径。
- long_query_time：慢查询阈值，当查询时间多于设定的阈值时，记录日志。默认 10.000000 秒，小数部分是微秒。
- log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）
-  log_output：日志存储方式，默认值为 FILE；TABLE 表示将日志存入数据库，日志信息会存入 mysql.slow_log 表中。也可以配置为 `FILE,TABLE`。

慢查询日志配置：

```
show variables like 'slow_query_log';   // 查看慢查询日志是否打开
set global slow_query_log = 1;   // 打开慢查询日志，只对当前数据库有效，MySQL 重启会失效。可以配置 my.cnf 永久有效
如何修改 my.cnf 以永久打开慢查询日志？增加或修改参数 
slow_query_log = 1
slow_query_log_file = /tmp/mysql_slow.log
```

当开启慢查询后，由 long_query_time 确认哪些 SQL 会记录到日志中。注意：想要 ` set global long_query_time = 4;` 修改慢查询时间阈值，需要重新连接或者重新开一个会话才能看到修改值。

```
mysql> select sleep(12);   // 睡眠 12 秒  

ash-5.0# cat  /var/lib/mysql/691db01cc7d0-slow.log  // 查看慢查询日志
mysqld, Version: 5.7.36 (MySQL Community Server (GPL)). started with:
Tcp port: 3306  Unix socket: /var/run/mysqld/mysqld.sock
Time                 Id Command    Argument
# Time: 2022-05-15T02:41:00.809608Z
# User@Host: root[root] @  [192.168.10.1]  Id:    58
# Query_time: 12.000204  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0
SET timestamp=1652582460;
select sleep(12);
```

可以指定日志的存储方式，将日志记录到数据库中

```
mysql> show variables like 'log_output';  // 查看日志的存储方式
mysql> set global log_output = 'TABLE';  // 设置存储到数据库
mysql> select * from mysql.slow_log;   // 从数据库表中查看慢查询日志
+----------------------------+------------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+------------------+-----------+
| start_time                 | user_host                    | query_time      | lock_time       | rows_sent | rows_examined | db | last_insert_id | insert_id | server_id | sql_text         | thread_id |
+----------------------------+------------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+------------------+-----------+
| 2022-05-15 10:47:07.653984 | root[root] @  [192.168.10.1] | 00:00:13.000243 | 00:00:00.000000 |         1 |             0 |    |              0 |         0 |         0 | select sleep(13) |        58 |
+----------------------------+------------------------------+-----------------+-----------------+-----------+---------------+----+----------------+-----------+-----------+------------------+-----------+
```

未使用索引的语句也可以被记录到慢查询日志中

```
mysql> show variables like 'log_queries_not_using_indexes';
mysql> set global log_queries_not_using_indexes = 1;

mysql> select * from mysql.slow_log;
+----------------------------+------------------------------+-----------------+-----------------+-----------+---------------+------+----------------+-----------+-----------+------------------------------------+-----------+
| start_time                 | user_host                    | query_time      | lock_time       | rows_sent | rows_examined | db   | last_insert_id | insert_id | server_id | sql_text                           | thread_id |
+----------------------------+------------------------------+-----------------+-----------------+-----------+---------------+------+----------------+-----------+-----------+------------------------------------+-----------+
| 2022-05-15 10:51:01.844616 | root[root] @  [192.168.10.1] | 00:00:00.000206 | 00:00:00.000076 |         1 |             1 | test |              0 |         0 |         0 | select * from mysql.slow_log       |        58 |
```

慢管理语句例如 analyze table 和 alter table 等也可以设置记录到慢查询

```
show variables like 'log_slow_admin_statements';
```

##### 3. 日志分析工具 mysqldumpslow

如果要手工分析日志，查找、分析 SQL，MySQL 提供了日志分析工具 mysqldumpslow

- -s：表示按照何种方式排序 
    - c 访问计数
    - l 锁定时间
    - r 返回时间
    - t 查询时间
    - al 平均锁定时间
    - ar 平均返回记录数
    - at 平均查询时间
- -t：是 top n 的意思，即为返回前面多少条的数据

```
得到返回记录集最多的10个SQL。
mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log

得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log

得到按照时间排序的前10条里面含有左连接的查询语句。
mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log

另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。
mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more
```

## 三、索引优化的手段

20条索引优化规则：https://www.51cto.com/article/625199.html

##### 1. 方法概览

使用 ` show index from table_name ` 查看一个表中的索引。

使用 ` explain+查询语句 ` ` 查看这个查询对于索引的命中情况。

使用 ` show status like 'Handler_read%'; ` 查看索引使用情况如下：

```
mysql> show status like 'Handler_read%';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 2     |
| Handler_read_key      | 5     |
| Handler_read_last     | 0     |
| Handler_read_next     | 1     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 32    |
+-----------------------+-------+
```

- Handler_read_key：如果索引正在工作，Handler_read_key 的值将很高
- Handler_read_rnd_next：数据文件中读取下一行的请求数，如果正在进行大量的表扫描，值将较高，则说明索引引用不理想

##### 2. 使用索引还是全表扫描

如果返回表中 30% 的数据会走索引，返回超过 30% 数据就会使用全表扫描。当然这个结论太绝对，不是绝对的 30%，只是一个大概的范围。因为数据量太多，使用索引可能导致回表次数太多，应该直接走全表扫描。比如

```
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `a` (`a`),
  KEY `t_modified` (`t_modified`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci 

mysql> select * from t;
+----+------+---------------------+
| id | a    | t_modified          |
+----+------+---------------------+
|  1 |    1 | 2018-11-13 00:00:00 |
|  2 |    2 | 2018-11-12 00:00:00 |
|  3 |    3 | 2018-11-11 00:00:00 |
|  5 |    5 | 2018-11-09 00:00:00 |
|  6 |    1 | 2022-05-14 15:14:29 |
|  7 |    1 | 2022-05-14 15:14:29 |
|  8 |    1 | 2022-05-14 15:14:29 |
|  9 |    1 | 2022-05-14 15:14:29 |
| 10 |    1 | 2022-05-14 15:14:29 |
+----+------+---------------------+

mysql> explain select * from t where a = 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t     | NULL       | ALL  | a             | NULL | NULL    | NULL |    9 |    66.67 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
```

如上，虽然表 t 的字段 a 上有索引，但是不会使用，因为 filtered 的值就是计算返回记录的比例数，总共有 9 行，其中 6 行是 a=1 的，因此 6/9 就是 filtered 的值。Explain 命令中 Extra 中 ` Using where ` 意味着需要回表取数据；`Using index ` 意味着不会回表。

##### 3. 索引优化规则

- 如果 MySQL 估计使用索引要比全表扫描还要慢，则不会使用索引。查询返回数据和全表数据的比例越低，越容易命中索引。一般是 30% 左右

- 前导模糊查询不能命中索引。在某个字段设置了普通索引。关注 key 这一列

    ```
    mysql> explain select * from user where name like '%a%';;   // %a% 前导模糊查询
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | user  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    7 |    14.29 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    
    mysql> explain select * from user where name like 'n%';   // a%  非前导模糊查询
    +----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
    | id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |
    +----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
    |  1 | SIMPLE      | user  | NULL       | range | name_index    | name_index | 363     | NULL |    2 |   100.00 | Using index condition |
    +----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+
    ```

- 数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符串常量值用引号引起来。关注 key 这一列

    ```
    mysql> explain select * from user where name = 6;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | user  | NULL       | ALL  | name_index    | NULL | NULL    | NULL |    7 |    14.29 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    
    mysql> explain select * from user where name = '6';
    +----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
    | id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
    +----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
    |  1 | SIMPLE      | user  | NULL       | ref  | name_index    | name_index | 363     | const |    1 |   100.00 | NULL  |
    +----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
    ```

- 复合索引的情况下，查询条件不包含索引列最左部分（不满足最左原则），不会命中复合索引

- 用 or 分割开的条件，如果 or 前的条件列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到。因为 or 后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加 IO 访问

- 负向条件查询不能使用索引，可以优化为 in 查询。但是前提是区分度要高，返回数据比例要在 30% 以内
    负向条件有：` !=、 <>、 not in、not exists、not like `等

- 范围条件查询可以命中索引。范围条件有：` <、<=、>、>=、between ` 等。
    如果查询条件中有两个范围列则无法全用到索引
    如果范围查询和等值查询同时存在，优先匹配等值查询列的索引

- 数据库执行计算不会命中索引，计算逻辑应该尽量放在业务层处理，节省数据库的 CPU的同时最大限度的命中索引

    ```
    mysql> explain select * from t where a+1 = 2;
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    | id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    |  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | Using where |
    +----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+
    ```

- 利用覆盖索引进行查询，避免回表

- 建立索引的列，不允许为 NULL。单列索引不存 NULL 值，复合索引不存全为 NULL 的值，如果列允许为 NULL，可能会得到“不符合预期”的结果集，所以，请使用 Not NULL 约束以及默认值。对MySQL来说，`null`是一个特殊的值，比如不能使用 `=， <， > ` 这样的运算符，对 NULL 做算术运算的结果都是 NULL，count 时不会包括 NULL 行等

- 更新十分频繁的字段上不宜建立索引，因为更新操作会变更 B+树，重建索引。这个过程十分消耗数据库性能

- 区分度不大的字段上不宜建立索引，类似于性别这种区分度不大的字段，建立索引的意义不大，不能有效过滤数据，性能和全表扫描相当

- 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。可以提升查询性能，少扫描一次。

- 多表关联查询时，要保证关联字段上一定要有索引

- 索引不是越多越好，索引越多，新增和插入时消耗越大

自己编写的SQL查询语句，要尽量使用EXPLAIN命令分析一下，做一个对SQL性能有追求的程序员



















