#### auto_ptr：拷贝时转移指针的所有权

```
template <typename T>
class smart_ptr {
	smart_ptr (smart_ptr& other) {
		ptr_ = other.release();
	}
	smart_ptr& operator=(smart_ptr& rhs) {
		smart_ptr(rhs).swap(*this);
		return *this;
	}
	T* release() {
		T* ptr = ptr_;
		ptr_ = nullptr;
		return ptr;
	}
	void swap(smart_ptr& rhs) {
		using std::swap;
		swap(ptr_, rhs.ptr_);
	}
};
```

上述代码中这种惯用法保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。

不过 auto_ptr 将它传递给另一个对象之后，就不再拥有这个对象了。

#### unique_ptr：移动指针

```
template <typename T> 
class smart_ptr {
	smart_ptr (smart_ptr&& other) {
		ptr_ = other.release();
	}
	smart_ptr& operator=(smart_ptr&& rhs) {
		rhs.swap(*this);
		return *this;
	}
};
```

必须以右值的形式传入，明确告诉用户对象已经转移

#### shared_ptr

通过引用计数的方式，多个智能指针可以拥有一个对象