## gcc 使用

在windows 下动态链接库是以 .dll 后缀的文件，linux 是以 .so 为后缀的文件。

### 一、gcc 在执行编译工作的时候，总共需要4步：

1. 预处理。生成.i 的文件【预处理器】
2. 将预处理后的文件转换成汇编语言，生成 .s 文件【编译器】
3. 将汇编变为目标代码，生成 .o 文件【汇编器】
4. 连接目标代码，生成可执行程序。【链接器】

### 二、参数

1. -c：进行预处理、编译、和汇编。也就是把程序作成 obj 文件
2. -S：进行预处理、编译，把文件编译成汇编代码
3. -E：进行预处理。不生成文件，因此需要重定向到一个输出文件里面。 Gcc -E hello.c > hello.txt
4. -o：制定目标名称。
5. -include file：包含某个代码，简单来说，就是便以某个文件，需要另一个文件的时候，就可以用它设定，功能就相当于代码中使用#include<filename>。 gcc hello.c -include /root/hello.h
6. -Idir：在使用“ #include “file” ”的时候，gcc 会在当前目录查找你所制定的头文件，如果没有找到，便回到默认的头文件目录找。如果使用 -I 制定了目录，他会先在你所制定的目录查找，然后再按常规的顺序去找。对于 #include<file> ，gcc/g++ 会到 -I 制定的目录查找，查找不到，然后将到系统的默认的头文件目录查找。
7. -idirafter dir：在 -I 的目录里面查找失败，就到这个目录里面查找
8. -C：在预处理的时候，不删除注释信息，一般和 -E 使用，有时候分析程序，这个很方便
9. -M：生成文件关联的信息。包含目标文件所依赖的所有源代码。
10. -MM：和-M 一样，但是它将忽略由#include<file> 造成的依赖。
11. -MD：和 -M 相同，但是输出将导入到 .d 文件里面
12. -MMD：和-MM 相同，但是输出将导入到 .d 文件里面
13. -llibrary：指定编译的时候使用的库。 gcc -lcurses hello.c ：使用 ncurses 库编译程序。
14. -Ldir：指定编译的时候，搜索库的路径。比如自己的库，可以用它指定目录，不然编译器将只在标准库的目录找。这个dir 就是目录的名称
15. -O0、-O1、-O2、-O3：编译器的优化选项的4个级别，-O0表示没有优化，-O1为默认值、-O3优化级别最高
16. -g：只是编译器，在编译的时候，产生调试信息，可以使用gdb
17. -static：此选项禁止使用动态库，所以编译出来的东西，一般都很大，也不需要什么动态链接库，就可以运行
18. -share：此选项尽量使用动态库，所以生成文件比较小，但是需要系统链接动态库。 
19. -w：不生成任何警告信息
20. -Wall：生成所有警告信息
21. -fPIC：为了在动态库中生成位置无关的代码。通过全局偏移表（GOT）访问所有常量地址。程序启动时动态加载程序解析GOT条目。
22. -fpic：和 -fPIC 相同，区别在于如果链接的可执行文件的GOT大小超过计算机特定的最大大小，则会从链接器收到错误消息，指示 -fpic 不起作用；在这种情况下，请使用 -fPIC 重新编译。GOT 大小根据操作系统的不同而大小不一样，SPARC上为8K，在AArch64 上为28k，x86没有限制。所以一般请使用 -fPIC选项。
22. -Wl,-options：把参数（options）传递给链接器 ld，如果 options 中间有逗号，就把 options 分成多个选项，然后传递给链接程序。



