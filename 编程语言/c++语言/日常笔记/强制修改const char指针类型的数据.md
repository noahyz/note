### 强制修改const char*类型的数据

首先来说明const 的位置不同所带来的语法规则不同

```c++
const char* a = "hello";
char* const b = "hello";
```

const 放在 * 号的前面，代表指针指向的内容不变，const 放在 * 号的后面，代表指针的指向不能改变。且在编译时 "hello" 会放在常量区。常量区的变量只可读不可修改。

```c++
char* a = "hello";
const char* b = a;
a[1] = '1'; // ok
b[1] = '1'; // error
char* c = const_cast<char*>(b);
c[1] = '1'; // ok
```

如上，a 所指向的字符串没有在常量区，让一个 const char* 的指针指向它也不会改变原有字符串的存储位置，只不过是规范了不能使用指针b去修改字符串。我们也可以使用 const_cast 来去掉指针b的不可修改指向字符串的属性。

```c++
const char* a = "hello";
char* b = const_cast<char*>(a);
b[1] = '1'; // error
```

 此代码在编译的时候不回报错，代码语法没有错误，但是会在运行时报错。指针a 所指向的字符串存储在常量区。虽然可以去掉指针a 本身的不可修改指向字符串内容的属性，但是无法改变所指向的字符串的存储区域。对于常量区的内容只可读，不可写。

#### 总结

- 能否修改一块内存空间，主要看这块内存空间在那个区域，常量区不可修改。堆栈区可修改。
- 既然有const 这种属性，那我们写代码就应该遵循这个约定，不要写可读性不好的代码