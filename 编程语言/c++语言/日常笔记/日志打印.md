## 宏定义封装的日志功能

使用宏定义封装的日志，可以很方便的切换不同的日志库，对应调试、线上发布很方便

#### 1. 使用不定参数的宏定义

c99 规范，编译器就开始支持不定参数 `##__VA_ARGS__` 。如下所示，需要的时候打开宏定义开关，不需要关闭即可

```c
#define __DEBUG

#ifdef __DEBUG
    #define xxxlog(format, ...) printf("[%s:%d:%s] " format, __FILE__, __LINE__, __func__, ##__VA_ARGS__)
#else
    #define xxxlog(format, ...)
#endif
```

#### 2. 分级日志

```c
#ifndef LOG_H_
#define LOG_H_

#define __LOG_SWITCH

// 定义日志模版
#ifdef __LOG_SWITCH
    #define LOG_TEMPLATE(format, ...) printf(format, ##__VA_ARGS__)
#else
    #define LOG_TEMPLATE(format, ...)
#endif 

// 定义日志级别
enum LOG_LEVEL {
    LOG_LEVEL_OFF = 0,
    LOG_LEVEL_FATAL,
    LOG_LEVEL_ERROR,
    LOG_LEVEL_WARN,
    LOG_LEVEL_INFO,
    LOG_LEVEL_DEBUG
};

// 全局的日志级别，需要保证线程安全
enum LOG_LEVEL log_level = LOG_LEVEL::LOG_LEVEL_DEBUG;

#define LOG_FATAL(format, ...)  \
    do {  \
        if (log_level >= LOG_LEVEL_FATAL)  \
            LOG_TEMPLATE("[FATAL FILE:%s LINE:%d FUNC:%s] " format "\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__);  \
    } while(0)

#define LOG_ERROR(format, ...)  \
    do {  \
        if (log_level >= LOG_LEVEL_ERROR)  \
            LOG_TEMPLATE("[ERROR FILE:%s LINE:%d FUNC:%s] " format "\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__);  \
    } while(0)

#define LOG_WARN(format, ...)  \
    do {  \
        if (log_level >= LOG_LEVEL_WARN)  \
            LOG_TEMPLATE("[WARN FILE:%s LINE:%d FUNC:%s] " format "\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__);  \
    } while(0)

#define LOG_INFO(format, ...)  \
    do {  \
        if (log_level >= LOG_LEVEL_INFO)  \
            LOG_TEMPLATE("[INFO FILE:%s LINE:%d FUNC:%s] " format "\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__);  \
    } while(0)

#define LOG_DEBUG(format, ...)  \
    do {  \
        if (log_level >= LOG_LEVEL_DEBUG)  \
            LOG_TEMPLATE("[DEBUG FILE:%s LINE:%d FUNC:%s] " format "\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__);  \
    } while(0)

#endif  // LOG_H_
```

