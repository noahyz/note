---
title: 19.c++输入
date: 2023-01-19 11:11:41
tags:
- linux
---

## c++中输入cin

系统的输入都有一个缓冲区，当一次键盘输入结束时会将输入的数据存入输入缓冲区，而cin对象直接从输入缓冲区中读取数据。正因为cin对象是直接从缓冲区取数据的，所以有时候当缓冲区有残留数据的时候，cin对象会直接取得这些残留数据而不会请求键盘输入。

#### 1. cin>>

- 当 cin>> 从缓冲区中读取数据的时候，若缓冲区中第一个字符是空格、tab或者换行这些分隔符时，cin>> 会将其忽略并清除，继续取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的。 cin>> 不做处理。
- 如果不想略过空白字符，可以使用 nosklpws 流控制。比如 cin >> noskipws >> a;
- getline(cin, str); getline 读取数据的时候，不会忽略输入缓冲区中换行、tab 等

#### 2. cin.get

- 读取单个字符，使用 `cin.get(ch) 或 ch=cin.get()` 
- cin.get() 的返回值是 int 类型，成功：读取字符的ASCII码值，遇到文件结束符时，返回EOF（-1）。
- cin.get(char val) 如果成功返回的是 cin 对象，因此可以支持 cin.get(b).get(c)
- cin.get() 从输入缓冲区读取单个字符时不忽略分隔符（空白符），直接将其读取。
- istream& get ( char* s, streamsize n, char delim ) 参数：字符数组，读入字符个数(长度-1)，结束符（默认为换行符）。不丢弃缓冲区的 Enter，自定义结束符时同样不丢弃缓冲区中的结束符。

#### 3. cin.getline

- 会在读取的字符串后面自动加上 '\0'

- cin.get()当输入的字符串超过规定长度时，不会引起cin函数的错误，后面的cin操作会继续执行，只是直接从缓冲区中取数据。但是cin.getline()当输入超过规定长度时，会引起cin函数的错误，后面的cin操作将不再执行。

- cin.get读取一行时，遇到换行符(自定义结束符)时结束读取，但是不对换行符(自定义结束符)进行处理，换行符(自定义结束符)仍然残留在输入缓冲区。

    getline读取一行字符时，默认遇到’\n’(自定义结束符)时终止，并且将’\n’(自定义结束符)直接从输入缓冲区中删除掉，不会影响下面的输入处理。

    两者都会在读取的字符串后面自动加上'\0'

- cin.get(str,size);读取一行时，只能将字符串读入C风格的字符串中，即char*，但是C++的getline函数还可以将字符串读入C++风格的字符串中，即string类型。

#### 4. 输入缓冲区清除方法

- cin.clear()是用来更改cin的状态标示符的，cin在接收到错误的输入的时候，会设置状态位good。如果good位不为1，则cin不接受输入，直接跳过。如果下次输入前状态位没有改变那么即使清除了缓冲区数据流也无法输入。所以清除缓冲区之前必须要cin.clear()。

- sync()的作用就是清除输入缓冲区。成功时返回0，失败时badbit会置位，函数返回-1。另外，对于绑定了输出的输入流，调用sync()，还会刷新输出缓冲区。 

- 有的时候我们想清除缓冲区中一部分而非全部内容。因此：

    ```c++
    cin.ignore(numeric_limits<std::streamsize>::max(),’\n’);//清除输入缓冲区的当前行 
    cin.ignore(numeric_limits<std::streamsize>::max()); //清除输入缓冲区里所有内容 
    cin.ignore()//清除一个字符
    ```

    

