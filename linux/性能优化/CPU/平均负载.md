---
title: undefined
date: 2023-01-19 11:11:41
tags:
- linux
---

## 一、平均负载概念

### 1. uptime命令

```shell
root@9-134-239-95:~# uptime
 22:52:30 up 265 days, 12:54,  1 user,  load average: 0.03, 0.06, 0.05
```
命令返回：
- `22:52:30`  表示当前时间
- `up 265 days, 12:54`  表示系统运行时间
- `1 user`  表示系统正在登录的用户数
- `load average: 0.03, 0.06, 0.05`  表示过去1分钟、5分钟、15分钟的平均负载

### 2. 平均负载

平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。
- 可运行状态的进程：是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用 ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程。
- 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程。

小总结：平均负载就是平均活跃进程数。那么最理想的情况是一个CPU运行一个进程，CPU被充分利用。比如平均负载为2，在1个CPU的机器上，意味着一半进程竞争不到CPU；在2个CPU的机器上，意味着所有CPU刚好被完全占有；在4个CPU的机器上，意味着CPU有50%的空闲。
- 如果最近1分钟、5分钟、15分钟的三个值基本相同，那就说明负载很平稳
- 如果最近1分钟远小于15分钟的值，说明最近1分钟的负载在降低，过去15分钟的负载稍高
- 如果最近1分钟远大于15分钟的值，说明负载在增加，如果平均负载接近或者超过CPU个数，意味着系统正在发生过载

一般情况下，当平均负载超过CPU数量的70%时，就需要关注负载高的问题；一旦负载高，会导致进程响应变慢，进而影响服务的正常功能

### 3. 区分平均负载和CPU使用率

平均负载：单位时间内，系统处于可运行状态和不可中断状态的平均进程数；所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。
CPU使用率：单位时间内，CPU的繁忙情况统计，和平均负载不一定完全对应

比如如下情况：
1. CPU密集型进程，使用大量CPU会使平均负载升高，此时两者是一致的
2. I/O密集型进程，等待I/O会导致平均负载升高，但CPU使用率不一定很高
3. 大量等待CPU的进程调度也会导致平均负载升高，此时CPU的使用率也会比较高

## 二、平均负载分析场景

- stress 是一个 linux 系统压力测试工具
- sysstat 包含了 linux 常用的性能工具，用来监控和分析系统的性能，比如 pidstat、mpstat 

### 1. CPU 密集型进程

- 在第一个终端运行 stress 命令，模拟一个 CPU 使用率 100% 的场景

    ```
    stress --cpu 1 --timeout 600
    ```

- 在第二个终端运行 uptime 命令查看平均负载的变化情况

    ```
    // -d 参数高亮显示变化的区域
    watch -d uptime
    ```

- 在第三个终端运行 mpstat 查看 CPU 使用率的变化情况。可以看到 0 号 cpu 的使用率 100%，但它的 iowait 只有 0，说明平均负载升高是因为 CPU 使用率达到了 100%  

    ```
    # -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
    ➜  [/root] mpstat -P ALL 5
    Linux 3.10.107-1-tlinux2_kvm_guest-0054 (9-134-239-95)  06/04/2022      _x86_64_        (8 CPU)
    
    05:44:31 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    05:44:36 PM  all   13.19    0.23    0.30    0.05    0.00    0.08    0.00    0.00    0.00   86.16
    05:44:36 PM    0   99.60    0.00    0.00    0.00    0.00    0.40    0.00    0.00    0.00    0.00
    05:44:36 PM    1    0.80    0.40    0.40    0.00    0.00    0.00    0.00    0.00    0.00   98.39
    05:44:36 PM    2    0.80    0.20    0.40    0.20    0.00    0.00    0.00    0.00    0.00   98.40
    05:44:36 PM    3    1.00    0.40    0.40    0.40    0.00    0.00    0.00    0.00    0.00   97.79
    ```

- 确定是那个进程导致了 CPU 使用率为 100%，使用 pidstat 来查看，可以看到 stress 进程的 CPU 使用率很高

    ```
    ➜  [/root] pidstat -u  5 1
    06:04:39 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
    06:04:44 PM     0     30590  100.00    0.00    0.00  100.00     6  stress
    ```

#### 2. IO 密集型进程

- 在第一个终端运行 stress 命令，模拟 IO 压力，即不停的执行 sync

    ```
    stress -i 1 --timeout 600
    ```

- 在第二个终端执行 uptime 查看平均负载的变化

    ```
    watch -d uptime
    ```

- 在第三个终端执行 mpstat 查看 CPU 使用率的情况。0 号 CPU 的内核态 CPU 时间占用 72.75%，磁盘 IO 等待时间 8.42% 。平均负载的升高是由于 iowait 的升高

    ```
    ➜  [/root] mpstat -P ALL 5 1
    Linux 3.10.107-1-tlinux2_kvm_guest-0054 (9-134-239-95)  06/04/2022      _x86_64_        (8 CPU)
    
    06:17:25 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    06:17:30 PM  all    0.68    0.23   10.61    1.86    0.00    0.10    0.00    0.00    0.00   86.52
    06:17:30 PM    0    0.60    0.00   72.75    8.42    0.00    0.00    0.00    0.00    0.00   18.24
    06:17:30 PM    1    0.40    0.40    7.03    6.02    0.00    0.40    0.00    0.00    0.00   85.74
    06:17:30 PM    2    0.60    0.00    0.81    0.40    0.00    0.00    0.00    0.00    0.00   98.19
    06:17:30 PM    3    1.00    0.20    2.00    0.00    0.00    0.20    0.00    0.00    0.00   96.61
    
    Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    Average:       0    0.47    0.07   73.25    9.01    0.00    0.13    0.00    0.00    0.00   17.08
    ```

- 使用 pidstat 查看，即可看到那个进程的 iowait 比较高。IO wait 导致的内核态 CPU 时间占用较高

    ```
    ➜  [/root] pidstat -u 3  3
    06:26:34 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
    06:26:37 PM     0      5318    0.00   76.67    0.00   76.67     0  stress
    ```

#### 3. 大量进程的场景

当系统中运行进程超过 CPU 运行能力时，就会出现等待 CPU 的进程

- 使用 stress 模拟多个进程，假如只有四个 CPU 

    ```
    // 模拟 8 个进程
    stress -c 8 --timeout 600 
    ```

- 使用 uptime 查看平均负载，使用 pidstat 查看进程的情况。8个进程在争抢 4 个 CPU，每个进程在用户空间占用的 CPU 只能到 50%

    ```
    ➜  [/root] pidstat -u 3  1
    06:33:16 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
    06:33:19 PM     0      9497   50.99    0.00    0.00   50.99     1  stress
    06:33:19 PM     0      9498   49.67    0.00    0.00   49.67     3  stress
    ...
    ```

    
